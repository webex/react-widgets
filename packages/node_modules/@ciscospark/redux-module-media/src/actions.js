import {constructCallState} from './helpers';

export const UPDATE_STATUS = 'media/UPDATE_STATUS';

export const DISMISS_INCOMING_CALL = 'media/DISMISS_INCOMING_CALL';
export const ANSWERED_INCOMING_CALL = 'media/ANSWERED_INCOMING_CALL';
export const STORE_CALL = 'media/STORE_CALL';
export const CONNECT_CALL = 'media/CONNECT_CALL';
export const REMOVE_CALL = 'media/REMOVE_CALL';
export const UPDATE_CALL_STATE = 'media/UPDATE_CALL_STATE';

export const CHECKING_WEB_RTC_SUPPORT = 'media/CHECKING_WEB_RTC_SUPPORT';
export const UPDATE_WEBRTC_SUPPORT = 'media/UPDATE_WEBRTC_SUPPORT';


function updateCallState(call, locusUrl, error = null) {
  return {
    type: UPDATE_CALL_STATE,
    payload: {
      call,
      callState: constructCallState(call, error),
      locusUrl
    }
  };
}


function updateStatus(status) {
  return {
    type: UPDATE_STATUS,
    payload: {
      status
    }
  };
}


function storeCall(call, locusUrl, isIncoming = false) {
  return {
    type: STORE_CALL,
    payload: {
      call,
      callState: constructCallState(call),
      isIncoming,
      locusUrl
    }
  };
}


function connectCall(call) {
  return {
    type: CONNECT_CALL,
    payload: {
      call,
      callState: constructCallState(call)
    }
  };
}


function removeCall(call, locusUrl) {
  return {
    type: REMOVE_CALL,
    payload: {
      call,
      locusUrl
    }
  };
}


function checkingWebRTCSupport() {
  return {
    type: CHECKING_WEB_RTC_SUPPORT
  };
}


export function updateWebRTCSupport(supported) {
  return {
    type: UPDATE_WEBRTC_SUPPORT,
    payload: {
      supported
    }
  };
}

/**
 * Dismisses an incoming call, marking it so.
 * Note: This does not decline the call, just for tracking purposes
 * @param {string} callId
 * @returns {object}
 */
export function dismissIncomingCall(callId) {
  return {
    type: DISMISS_INCOMING_CALL,
    payload: {
      callId
    }
  };
}

function answeredIncomingCall(callId) {
  return {
    type: ANSWERED_INCOMING_CALL,
    payload: {
      callId
    }
  };
}

export function hangupCall({call, locusUrl}) {
  return (dispatch) => {
    // Don't update call states after hangup
    call.off();
    return call.hangup().then(() => dispatch(removeCall(call, locusUrl)));
  };
}


function bindEvents(dispatch, call, locusUrl) {
  call.once('active', () => dispatch(connectCall(call)));
  call.once('inactive', () => dispatch(hangupCall({call})));
  call.on('change:locus', () => dispatch(updateCallState(call, locusUrl)));
  call.on('change:state', () => dispatch(updateCallState(call, locusUrl)));
  call.on('change:sendingAudio', () => dispatch(updateCallState(call, locusUrl)));
  call.on('change:receivingAudio', () => dispatch(updateCallState(call, locusUrl)));
  call.on('change:sendingVideo', () => dispatch(updateCallState(call, locusUrl)));
  call.on('change:receivingVideo', () => dispatch(updateCallState(call, locusUrl)));
  call.on('change:activeParticipantsCount', () => dispatch(updateCallState(call, locusUrl)));
  call.on('remoteAudioMuted:change', () => dispatch(updateCallState(call, locusUrl)));
  call.on('remoteVideoMuted:change', () => dispatch(updateCallState(call, locusUrl)));
  call.on('remoteMediaStream:change', () => dispatch(updateCallState(call, locusUrl)));
  call.on('localMediaStream:change', () => dispatch(updateCallState(call, locusUrl)));
  call.on('change:joinedOnThisDevice', () => dispatch(updateCallState(call, locusUrl)));
  call.on('membership:notified', () => dispatch(updateCallState(call, locusUrl)));
  call.on('membership:disconnected', () => dispatch(updateCallState(call, locusUrl)));
  call.on('membership:change', () => dispatch(updateCallState(call, locusUrl)));
  call.on('memberships:add', () => dispatch(updateCallState(call, locusUrl)));
  call.on('memberships:remove', () => dispatch(updateCallState(call, locusUrl)));
  call.on('membership:declined', () => {
    if (call.isCall && call.remoteMember && call.remoteMember.state === 'declined') {
      // Hang up if the remote person declines the call
      return dispatch(hangupCall({call}));
    }
    return dispatch(updateCallState(call, locusUrl));
  });
  call.on('error', (err) => dispatch(updateCallState(call, locusUrl, err)));
}


/**
 * Call a user with an email address or userId
 *
 * @export
 * @param {String} data.destination
 * @param {String} data.locusUrl Optional id we use in the store for a specific call
 * @param {Object} data.constraints
 * @param {Object} sparkInstance
 * @returns {Promise}
 */
export function placeCall({
  destination,
  locusUrl,
  constraints = {audio: true, video: true}
}, sparkInstance) {
  return (dispatch) => {
    let call;
    try {
      call = sparkInstance.phone.dial(
        destination,
        Object.assign({
          constraints,
          offerOptions: {offerToReceiveVideo: true, offerToReceiveAudio: true}
        })
      );
      dispatch(storeCall(call, locusUrl));
      bindEvents(dispatch, call, locusUrl);
    }
    catch (e) {
      // Ignore, will be caught on call.on('error')
    }
    return Promise.resolve(call);
  };
}

/**
 * Declines an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Promise}
 */
export function declineIncomingCall(incomingCall) {
  return (dispatch) => {
    incomingCall.reject();
    return dispatch(dismissIncomingCall(incomingCall.locus.url));
  };
}

/**
 * Answers a call object
 * @param {object} incomingCall
 * @param {string} locusUrl
 * @returns {Promise}
 */
export function acceptIncomingCall(incomingCall, locusUrl) {
  return (dispatch) =>
    incomingCall.answer({offerOptions: {offerToReceiveVideo: true, offerToReceiveAudio: true}})
      .then(() => {
        bindEvents(dispatch, incomingCall, locusUrl);
        return dispatch(connectCall(incomingCall));
      });
}


/**
 * Listen for incoming calls and sets up call handling
 *
 * @export
 * @param {Object} sparkInstance
 * @param {String} locusUrl if limiting listener to single locusUrl
 * @returns {Promise}
 */
export function listenForIncomingCalls(sparkInstance, locusUrl) {
  return (dispatch) => {
    dispatch(updateStatus({isListening: true}));
    return sparkInstance.phone.on('call:incoming', (incomingCall) => {
      // If locusUrl is passed, only listen to specific locus
      if (locusUrl && incomingCall.locus.url !== locusUrl) {
        return false;
      }

      // If we make an outbound call via the widget, when the remote party answers,
      // we get a call:incoming notification when they connect
      if (incomingCall.direction === 'out') {
        return false;
      }

      return incomingCall.acknowledge()
        .then(() => {
          const removeIncoming = () => dispatch(removeCall(incomingCall, incomingCall.locus.url));

          // If the remote party hangs up before we accept/decline
          incomingCall.once('inactive', removeIncoming);

          // If we rejected the call elsewhere, mark it declined
          incomingCall.on('membership:declined', () => {
            if (incomingCall.me.state === 'declined') {
              dispatch(dismissIncomingCall(incomingCall.locus.url));
            }
          });

          incomingCall.on('membership:change', () => {
            // Once we are connected, our connected call state will handle disconnects
            if (incomingCall.me.state === 'connected') {
              dispatch(answeredIncomingCall(incomingCall.locus.url));
              // incomingCall.joinedOnThisDevice takes a few ticks so we have to
              // calculate it ourselves for now
              if (incomingCall.locus.self.deviceUrl !== sparkInstance.internal.device.url) {
                // We are not connected on this device, dismiss
                dispatch(dismissIncomingCall(incomingCall.locus.url));
              }
            }
          });

          return dispatch(storeCall(incomingCall, incomingCall.locus.url, true));
        });
    });
  };
}

/**
 * Check for browser webRTC support
 *
 *  @param {object} sparkInstance
 *  @returns {Promise}
 */
export function checkWebRTCSupport(sparkInstance) {
  return (dispatch) => {
    dispatch(checkingWebRTCSupport());
    return sparkInstance.phone.isCallingSupported().then((supported) => dispatch(updateWebRTCSupport(supported)));
  };
}
