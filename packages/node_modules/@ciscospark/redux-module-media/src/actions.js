/* eslint no-use-before-define: ["error", { "functions": false }] */

import uuid from 'uuid';

import {constructCallObject} from './helpers';

export const UPDATE_STATUS = 'media/UPDATE_STATUS';

export const DISMISS_INCOMING_CALL = 'media/DISMISS_INCOMING_CALL';
export const ANSWERED_INCOMING_CALL = 'media/ANSWERED_INCOMING_CALL';
export const STORE_CALL = 'media/STORE_CALL';
export const UPDATE_CALL_STATUS = 'media/UPDATE_CALL_STATUS';
export const UPDATE_CALL_ERROR = 'media/UPDATE_CALL_ERROR';
export const REMOVE_CALL = 'media/REMOVE_CALL';

export const CHECKING_WEB_RTC_SUPPORT = 'media/CHECKING_WEB_RTC_SUPPORT';
export const UPDATE_WEBRTC_SUPPORT = 'media/UPDATE_WEBRTC_SUPPORT';

/* Actions */

function answeredIncomingCall(callId) {
  return {
    type: ANSWERED_INCOMING_CALL,
    payload: {
      id: callId
    }
  };
}

function checkingWebRTCSupport() {
  return {
    type: CHECKING_WEB_RTC_SUPPORT
  };
}

function removeCall(id) {
  return {
    type: REMOVE_CALL,
    payload: {
      id
    }
  };
}

export function storeCall({call, id, destination}) {
  // check if this is a locus replaced call
  return {
    type: STORE_CALL,
    payload: {
      id,
      call: constructCallObject(call),
      destination
    }
  };
}

function updateCallError(call, error) {
  return {
    type: UPDATE_CALL_ERROR,
    payload: {
      id: call.id,
      call: constructCallObject(call),
      error
    }
  };
}

function updateCallStatus({call, id, eventName}) {
  return {
    type: UPDATE_CALL_STATUS,
    payload: {
      id,
      call: constructCallObject(call),
      eventName
    }
  };
}

function updateStatus(status) {
  return {
    type: UPDATE_STATUS,
    payload: {
      status
    }
  };
}

function updateWebRTCSupport(supported) {
  return {
    type: UPDATE_WEBRTC_SUPPORT,
    payload: {
      supported
    }
  };
}

/* Exported Actions */

/**
 * Accepts an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Promise}
 */
export function acceptIncomingCall(incomingCall) {
  return (dispatch) =>
    incomingCall.instance.answer({
      offerOptions: {offerToReceiveVideo: true, offerToReceiveAudio: true}
    })
      .then(() => {
        bindEvents({
          dispatch,
          call: incomingCall.instance,
          id: incomingCall.id
        });
        dispatch(updateCallStatus({
          call: incomingCall.instance,
          id: incomingCall.id
        }));
        return incomingCall;
      });
}

/**
 * Does a spark API request for existing calls and stores them
 * @param {object} sparkInstance
 * @returns {Promise}
 */
export function checkCurrentCalls(sparkInstance) {
  return (dispatch) => sparkInstance.phone.listActiveCalls()
    .then((results) => Promise.all(results.map((callObject) => {
      const id = uuid.v4();
      bindEvents({dispatch, call: callObject, id});
      return dispatch(storeCall({call: callObject, id}));
    })));
}

/**
 * Check for browser webRTC support
 *
 *  @param {object} sparkInstance
 *  @returns {Promise}
 */
export function checkWebRTCSupport(sparkInstance) {
  return (dispatch) => {
    if (sparkInstance.phone) {
      dispatch(checkingWebRTCSupport());
      return sparkInstance.phone.isCallingSupported()
        .then((supported) => dispatch(updateWebRTCSupport(supported)));
    }
    return Promise.resolve();
  };
}

/**
 * Declines an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Thunk}
 */
export function declineIncomingCall(incomingCall) {
  return (dispatch) => {
    incomingCall.instance.reject();
    dispatch(removeCall(incomingCall.id));
    return Promise.resolve();
  };
}

/**
 * Dismisses an incoming call, marking it so.
 * Note: This does not decline the call, just for tracking purposes
 * @param {string} id
 * @returns {object}
 */
export function dismissIncomingCall(id) {
  return {
    type: DISMISS_INCOMING_CALL,
    payload: {
      id
    }
  };
}

/**
 * Hangs up and removes call
 * @param {object} call
 * @returns {Promise}
 */
export function hangupCall({call, id}) {
  return (dispatch) => {
    // Don't update call states after hangup
    call.off();
    // Only call.hangup() when local user wants to hangup.
    // SDK handles .hangup() when call becomes `inactive`
    return call.hangup()
      .then(() => dispatch(removeCall(id)))
      .catch(() => dispatch(removeCall(id)));
  };
}

/**
 * Listens for all call events from phone plugin and handles them
 * @param {Object} sparkInstance
 * @returns {Promise}
 */
export function listenForCalls(sparkInstance) {
  return (dispatch) => {
    dispatch(updateStatus({isListening: true, isListeningToIncoming: true}));
    return Promise.all([
      handleIncomingCalls(sparkInstance),
      handleCreatedCalls(sparkInstance, dispatch)
    ]);
  };
}

/**
 * Call a user with an email address or userId
 *
 * @export
 * @param {Object} sparkInstance
 * @param {String} data.destination
 * @param {Object} data.options
 * @returns {Promise}
 */
export function placeCall(sparkInstance, {
  destination,
  options = {audio: true, video: true}
}) {
  return (dispatch) => {
    let call, id;
    try {
      call = sparkInstance.phone.dial(
        destination,
        Object.assign(
          options,
          {
            offerOptions: {offerToReceiveVideo: true, offerToReceiveAudio: true}
          }
        )
      );
      ({id} = bindEvents({dispatch, call}));
      dispatch(storeCall({call, id, destination}));
    }
    catch (e) {
      // Ignore, will be caught on call.on('error')
    }
    return Promise.resolve({call, id});
  };
}

/**
 * Registers the client for media/phone
 * @param {object} sparkInstance
 * @returns {Promise}
 */
export function registerClient(sparkInstance) {
  return (dispatch) => sparkInstance.phone.register().then(() => {
    const status = {isRegistered: true};
    dispatch(updateStatus(status));
    return Promise.resolve(status);
  });
}

/**
 * Process and store a call object from outside widgets
 * @param {Object} call
 * @returns {Function}
 */
export function storeExternalCall(call) {
  return (dispatch) => {
    const {id} = bindEvents({dispatch, call});
    dispatch(storeCall({call}));
    return {id, call};
  };
}


/* Helper Functions */

function bindEvents({dispatch, call, id}) {
  const callId = id || uuid.v4();

  const updateCall = (callInstance, eventName) =>
    dispatch(updateCallStatus({
      call: callInstance,
      id: callId,
      eventName
    }));

  call.once('active', () => dispatch(updateCall(call, 'active')));
  call.once('inactive', () => dispatch(removeCall(callId)));
  call.on('change:locus', () => {
    updateCall(call, 'change:locus');
  });

  [
    'change:state',
    'change:sendingAudio',
    'change:receivingAudio',
    'change:sendingVideo',
    'change:receivingVideo',
    'change:activeParticipantsCount',
    'remoteAudioMuted:change',
    'remoteVideoMuted:change',
    'remoteMediaStream:change',
    'localMediaStream:change',
    'change:joinedOnThisDevice',
    'membership:notified',
    'membership:disconnected',
    'membership:change',
    'memberships:add',
    'memberships:remove'
  ].map((event) => updateCall(call, event));

  if (call.direction === 'out') {
    // If we rejected the call elsewhere, remove it
    call.on('membership:declined', () => {
      if (call.me.state === 'rejected') {
        dispatch(dismissIncomingCall(callId));
      }
    });

    call.on('membership:change', () => {
      // Once we are connected, our connected call state will handle disconnects
      if (call.me.state === 'connected') {
        dispatch(answeredIncomingCall(callId));
        // incomingCall.joinedOnThisDevice takes a few ticks so we have to
        // calculate it ourselves for now
        if (call.locus.self.deviceUrl !== call.spark.internal.device.url) {
          // We are not connected on this device, dismiss
          dispatch(dismissIncomingCall(callId));
        }
      }
    });
  }

  call.on('membership:declined', () => {
    if (call.isCall && call.remoteMember && call.remoteMember.state === 'declined') {
      // Hang up if the remote person declines the call
      return dispatch(hangupCall({call, id: callId}));
    }
    if (call.me.state === 'rejected') {
      dispatch(dismissIncomingCall(callId));
    }
    return updateCall(call, 'membership:declined');
  });
  call.on('error', (err) => dispatch(updateCallError(call, err)));

  return {call, id: callId};
}

/**
 * Sets up event listener for the 'call:incoming' phone event
 * @param {object} sparkInstance
 * @param {object} dispatch
 * @returns {Promise}
 */
function handleIncomingCalls(sparkInstance) {
  return sparkInstance.phone.on('call:incoming', (incomingCall) => {
    // If we make an outbound call via the widget, when the remote party answers,
    // we get a call:incoming notification when they connect
    if (incomingCall.direction === 'out') {
      return false;
    }

    return incomingCall.acknowledge();
  });
}

/**
 * Sets up event listener for the 'call:created' phone event
 * @param {object} sparkInstance
 * @param {object} dispatch
 * @returns {Promise}
 */
function handleCreatedCalls(sparkInstance, dispatch) {
  return sparkInstance.phone.on('call:created', (createdCall) => {
    // Do not store call when a created inactive call comes in
    if (createdCall.state !== 'inactive') {
      const id = uuid.v4();
      bindEvents({dispatch, call: createdCall, id});
      dispatch(storeCall({call: createdCall, id}));
    }

    return Promise.resolve(createdCall);
  });
}
