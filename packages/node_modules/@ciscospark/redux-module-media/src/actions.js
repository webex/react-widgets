export const UPDATE_STATUS = `media/UPDATE_STATUS`;
export const STORE_CALL = `media/STORE_CALL`;
export const UPDATE_CALL_STATE = `media/UPDATE_CALL_STATE`;
export const CONNECT_CALL = `media/CONNECT_CALL`;
export const REMOVE_CALL = `media/REMOVE_CALL`;
export const CHECK_WEBRTC_SUPPORT = `media/CHECK_WEBRTC_SUPPORT`;
export const UPDATE_WEBRTC_SUPPORT = `media/UPDATE_WEBRTC_SUPPORT`;


export function updateCallState(call, locusUrl) {
  return {
    type: UPDATE_CALL_STATE,
    payload: {
      call,
      callState: constructCallState(call),
      locusUrl
    }
  };
}


export function updateStatus(status) {
  return {
    type: UPDATE_STATUS,
    payload: {
      status
    }
  };
}


export function storeCall(call, locusUrl) {
  return {
    type: STORE_CALL,
    payload: {
      call,
      callState: constructCallState(call),
      locusUrl
    }
  };
}


function connectCall(call) {
  return {
    type: CONNECT_CALL,
    payload: {
      call,
      callState: constructCallState(call)
    }
  };
}


export function removeCall(call) {
  return {
    type: REMOVE_CALL,
    payload: {
      call
    }
  };
}


export function checkingWebRTCSupport() {
  return {
    type: CHECK_WEBRTC_SUPPORT
  };
}


export function updateWebRTCSupport(supported) {
  return {
    type: UPDATE_WEBRTC_SUPPORT,
    payload: {
      supported
    }
  };
}

/**
 * Call a user with an email address or userId
 *
 * @export
 * @param {String} data.userIdOrEmail
 * @param {String} data.locusUrl Optional id we use in the store for a specific call
 * @param {Object} data.constraints
 * @param {Object} sparkInstance
 * @returns {Promise}
 */

export function callUser({
  userIdOrEmail,
  locusUrl,
  constraints = {audio: true, video: true}
}, sparkInstance) {
  return (dispatch) =>
    sparkInstance.phone.createLocalMediaStream(constraints)
      .then((localMediaStream) => {

        const call = sparkInstance.phone.dial(
          userIdOrEmail,
          Object.assign({
            constraints,
            offerOptions: {offerToReceiveVideo: true, offerToReceiveAudio: true}
          }, {localMediaStream})
        );

        dispatch(storeCall(call, locusUrl));
        dispatch(updateCallState(call, locusUrl));
        bindEvents(dispatch, call, locusUrl);
        return Promise.resolve(call);
      });
}


export function hangupCall(call) {
  return (dispatch) => {
    // Don't update call states after hangup
    call.off();
    return call.hangup().then(() => {
      dispatch(removeCall(call));
    });
  };
}

/**
 * Listen for incoming calls and sets up call handling
 *
 * @export
 * @param {Object} sparkInstance
 * @param {String} locusUrl if limiting listener to single locusUrl
 * @returns {Promise}
 */
export function listenForIncomingCalls(sparkInstance, locusUrl) {
  return (dispatch) => {
    sparkInstance.phone.on(`call:incoming`, (incomingCall) => {
      // If locusUrl is passed, only listen to specific locus
      if (locusUrl && incomingCall.locus.url !== locusUrl) {
        return;
      }

      // If we make an outbound call via the widget, when the remote party answers,
      // we get a call:incoming notification when they connect
      if (incomingCall.direction === `out`) {
        return;
      }

      incomingCall.acknowledge()
        .then(() => {
          dispatch(storeCall(incomingCall));
          const removeIncoming = () => dispatch(removeCall(incomingCall));

          // Disconnects will happen if the remote party hangs up before we accept/decline
          incomingCall.once(`disconnected`, removeIncoming);
          // Once we are connected, our connected call state will handle disconnects
          incomingCall.once(`connected`, () => incomingCall.off(`disconnected`, removeIncoming));
          bindEvents(dispatch, incomingCall);
        });
    });
    dispatch(updateStatus({isListening: true}));
  };
}

/**
 * Declines an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Promise}
 */
export function declineIncomingCall(incomingCall) {
  return (dispatch) => {
    incomingCall.reject()
      .then(() => {
        dispatch(removeCall(incomingCall));
      });
  };
}

export function acceptIncomingCall(incomingCall) {
  return (dispatch) => {
    incomingCall.answer({offerOptions: {offerToReceiveVideo: true, offerToReceiveAudio: true}})
      .then(() => {
        dispatch(connectCall(incomingCall));
      });
  };
}


/**
 * Check for browser webRTC support
 *
 *  @param {object} spark
 *  @returns {Promise}
 */
export function checkWebRTCSupport(spark) {
  return (dispatch) => {
    dispatch(checkingWebRTCSupport());
    spark.phone.isCallingSupported().then((supported) => {
      dispatch(updateWebRTCSupport(supported));
    });
  };
}


function constructCallState(call) {
  let remoteAudioMuted, remoteVideoMuted;
  try {
    remoteAudioMuted = call.remoteAudioMuted;
    remoteVideoMuted = call.remoteVideoMuted;
  }
  catch (e) {
    // eslint-disable-line no-console
  }
  return {
    direction: call.direction,
    joined: call.joined,
    joinedOnThisDevice: call.joinedOnThisDevice,
    connected: call.status === `connected`,
    ringing: call.status === `ringing`,
    initiated: call.status === `initiated`,
    receivingAudio: call.receivingAudio,
    receivingVideo: call.receivingVideo,
    sendingAudio: call.sendingAudio,
    sendingVideo: call.sendingVideo,
    remoteMediaStream: call.remoteMediaStream,
    localMediaStream: call.localMediaStream,
    remoteAudioMuted,
    remoteVideoMuted
  };
}

function bindEvents(dispatch, call, locusUrl) {
  call.once(`connected`, () => dispatch(connectCall(call)));
  call.once(`disconnected`, () => dispatch(hangupCall(call)));
  call.on(`change:status`, () => dispatch(updateCallState(call, locusUrl)));
  call.on(`change:sendingAudio`, () => dispatch(updateCallState(call, locusUrl)));
  call.on(`change:receivingAudio`, () => dispatch(updateCallState(call, locusUrl)));
  call.on(`change:sendingVideo`, () => dispatch(updateCallState(call, locusUrl)));
  call.on(`change:receivingVideo`, () => dispatch(updateCallState(call, locusUrl)));
  call.on(`remoteAudioMuted:change`, () => dispatch(updateCallState(call, locusUrl)));
  call.on(`remoteVideoMuted:change`, () => dispatch(updateCallState(call, locusUrl)));
  call.on(`remoteMediaStream:change`, () => dispatch(updateCallState(call, locusUrl)));
  call.on(`localMediaStream:change`, () => dispatch(updateCallState(call, locusUrl)));
  call.on(`change:joined`, () => dispatch(updateCallState(call, locusUrl)));
  call.on(`change:joinedOnThisDevice`, () => dispatch(updateCallState(call, locusUrl)));
}
