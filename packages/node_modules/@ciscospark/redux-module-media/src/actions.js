
export const UPDATE_MEDIA_STATE = `media/UPDATE_MEDIA_STATE`;
export function updateMediaState(call) {
  return {
    type: UPDATE_MEDIA_STATE,
    payload: {
      call
    }
  };
}

export const UPDATE_CALL_STATE = `media/UPDATE_CALL_STATE`;
export function updateCallState(call) {
  return {
    type: UPDATE_CALL_STATE,
    payload: {
      call
    }
  };
}

export const UPDATE_STATUS = `media/UPDATE_STATUS`;
export function updateStatus(status) {
  return {
    type: UPDATE_STATUS,
    payload: {
      status
    }
  };
}

export const STORE_CALL = `media/STORE_CALL`;
export function storeCall(call) {
  return {
    type: STORE_CALL,
    payload: {
      call
    }
  };
}

export const CALL_CONNECTED = `media/CALL_CONNECTED`;
export function callConnected(call) {
  return {
    type: CALL_CONNECTED,
    payload: {
      call
    }
  };
}

export const CALL_DISCONNECTED = `media/CALL_DISCONNECTED`;
export function callDisconnected() {
  return {
    type: CALL_DISCONNECTED
  };
}

export const CALL_INCOMING = `media/CALL_INCOMING`;
export function callIncoming(call) {
  return {
    type: CALL_INCOMING,
    payload: {
      call
    }
  };
}

export const ANSWER_INCOMING_CALL = `media/ANSWER_INCOMING_CALL`;
export function answerIncomingCall(call) {
  return {
    type: ANSWER_INCOMING_CALL,
    payload: {
      call
    }
  };
}

export const REMOVE_INCOMING_CALL = `media/REMOVE_INCOMING_CALL`;
export function removeCallIncoming(call) {
  return {
    type: REMOVE_INCOMING_CALL,
    payload: {
      call
    }
  };
}

export const UPDATE_LOCAL_MEDIA = `media/UPDATE_LOCAL_MEDIA`;
export function updateLocalMedia(call) {
  return {
    type: UPDATE_LOCAL_MEDIA,
    payload: {
      call
    }
  };
}

export const UPDATE_REMOTE_MEDIA = `media/UPDATE_REMOTE_MEDIA`;
export function updateRemoteMedia(call) {
  return {
    type: UPDATE_REMOTE_MEDIA,
    payload: {
      call
    }
  };
}

export const CHECKING_WEBRTC_SUPPORT = `media/CHECKING_WEBRTC_SUPPORT`;
export function checkingWebRTCSupport(status) {
  return {
    type: CHECKING_WEBRTC_SUPPORT,
    payload: {
      status
    }
  };
}

export const UPDATE_WEBRTC_SUPPORT = `media/UPDATE_WEBRTC_SUPPORT`;
export function updateWebRTCSupport(supported) {
  return {
    type: UPDATE_WEBRTC_SUPPORT,
    payload: {
      supported
    }
  };
}

export function bindCallActions(dispatch, call) {
  call.once(`connected`, () => dispatch(callConnected(call)));
  call.once(`disconnected`, () => dispatch(hangupCall(call)));
  call.on(`change:status`, () => dispatch(updateCallState(call)));
  call.on(`change:sendingAudio`, () => dispatch(updateCallState(call)));
  call.on(`change:receivingAudio`, () => dispatch(updateCallState(call)));
  call.on(`change:sendingVideo`, () => dispatch(updateCallState(call)));
  call.on(`change:receivingVideo`, () => dispatch(updateCallState(call)));
  call.on(`remoteAudioMuted:change`, () => dispatch(updateCallState(call)));
  call.on(`remoteVideoMuted:change`, () => dispatch(updateCallState(call)));
}

export function bindMediaActions(dispatch, call) {
  call.on(`remoteMediaStream:change`, () => dispatch(updateRemoteMedia(call)));
  call.on(`localMediaStream:change`, () => dispatch(updateLocalMedia(call)));
}

export function callUser({userIdOrEmail, constraints = {audio: true, video: true}}, spark) {
  return (dispatch) => {
    spark.phone.createLocalMediaStream(constraints)
      .then((localMediaStream) => {
        dispatch(updateStatus({isDialing: true}));
        const call = spark.phone.dial(
          userIdOrEmail,
          Object.assign({
            constraints,
            offerOptions: {offerToReceiveVideo: true, offerToReceiveAudio: true}
          }, {localMediaStream})
        );
        dispatch(storeCall(call));
        dispatch(updateCallState(call));
        bindCallActions(dispatch, call);
        bindMediaActions(dispatch, call);
      });
  };
}

export function hangupCall(call) {
  return (dispatch) => {
    // Don't update call states after hangup
    call.off();
    call.hangup().then(() => {
      dispatch(callDisconnected());
    });
  };
}

/**
 * Listen for incoming calls and sets up call handling
 *
 * @export
 * @param {Object} spark
 * @param {String} locusUrl
 * @param {Function} handleEvent
 * @returns {Promise}
 */
export function listenForIncomingCalls(spark, locusUrl, handleEvent) {
  return (dispatch, getState) => {
    if (getState().media.getIn([`status`, `isListening`])) {
      return;
    }
    spark.phone.on(`call:incoming`, (incomingCall) => {
      // We only acknowledge calls directly related to this widget
      if (incomingCall.locus.url !== locusUrl) {
        return;
      }
      // If we make an outbound call via the widget, when the remote party answers,
      // we get a call:incoming notification when they connect
      if (getState().media.getIn([`status`, `isDialing`])) {
        return;
      }
      incomingCall.acknowledge()
        .then(() => {
          dispatch(callIncoming(incomingCall));
          const removeIncoming = () => dispatch(removeCallIncoming(incomingCall));

          // Disconnects will happen if the remote party hangs up before we accept/decline
          incomingCall.once(`disconnected`, removeIncoming);
          // Once we are connected, our connected call state will handle disconnects
          incomingCall.once(`connected`, () => incomingCall.off(`disconnected`, removeIncoming));
          bindCallActions(dispatch, incomingCall);
          bindMediaActions(dispatch, incomingCall);
          // Emit the event
          handleEvent(`calls:ringing`, {
            actor: incomingCall.from.person,
            call: incomingCall
          });
        });
    });
    dispatch(updateStatus({isListening: true}));
  };
}

/**
 * Declines an incoming call
 *
 * @export
 * @param {object} incomingCall
 * @returns {Promise}
 */
export function declineIncomingCall(incomingCall) {
  return (dispatch) => {
    incomingCall.reject()
      .then(() => {
        dispatch(removeCallIncoming(incomingCall));
      });
  };
}

export function acceptIncomingCall(incomingCall) {
  return (dispatch) => {
    incomingCall.answer({offerOptions: {offerToReceiveVideo: true, offerToReceiveAudio: true}})
      .then(() => {
        dispatch(answerIncomingCall(incomingCall));
      });
  };
}

/**
 * Check for brwoser webRTC support
 *
 *  @param {object} spark
 *  @returns {Promise}
 */
export function checkWebRTCSupport(spark) {
  return (dispatch) => {
    dispatch(checkingWebRTCSupport());
    spark.phone.isCallingSupported().then((supported) => {
      dispatch(updateWebRTCSupport(supported));
    });
  };
}
