import {fromJS} from 'immutable';

import {
  UPDATE_STATUS,
  UPDATE_CALL_STATE,
  UPDATE_LOCAL_MEDIA,
  UPDATE_REMOTE_MEDIA,
  CALL_CONNECTED,
  CALL_DISCONNECTED,
  STORE_CALL,
  CALL_INCOMING,
  ANSWER_INCOMING_CALL,
  REMOVE_INCOMING_CALL,
  CHECKING_WEBRTC_SUPPORT,
  UPDATE_WEBRTC_SUPPORT
} from './actions';

export const initialState = fromJS({
  call: null,
  startTime: null,
  incomingCall: {
    hasAcknowledged: false,
    call: null
  },
  callState: {
    sendingAudio: false,
    sendingVideo: false
  },
  webRTC: {
    isCheckingSupport: false,
    isSupported: null
  },
  status: {
    isDialing: false,
    isListening: false,
    isRinging: false,
    isConnected: false,
    hasSelfView: false
  }
});


// eslint-disable-next-line complexity
export default function reducer(state = initialState, action) {
  switch (action.type) {
  case UPDATE_STATUS:
    return state.mergeIn([`status`], action.payload.status);
  case UPDATE_CALL_STATE: {
    let remoteAudioMuted, remoteVideoMuted;
    const call = action.payload.call;
    try {
      remoteAudioMuted = call.remoteAudioMuted;
      remoteVideoMuted = call.remoteVideoMuted;
    }
    catch (e) {
      console.warn(e); // eslint-disable-line no-console
    }

    const callState = {
      receivingAudio: call.receivingAudio,
      receivingVideo: call.receivingVideo,
      sendingAudio: call.sendingAudio,
      sendingVideo: call.sendingVideo,
      localAudioDirection: call.localAudioDirection,
      localVideoDirection: call.localVideoDirection,
      remoteMediaStream: call.remoteMediaStream,
      localMediaStream: call.localMediaStream,
      remoteAudioMuted,
      remoteVideoMuted
    };
    return state.mergeIn([`callState`], callState);
  }
  case UPDATE_LOCAL_MEDIA: {
    const call = action.payload.call;
    const mediaState = {
      localAudioDirection: call.localAudioDirection,
      localVideoDirection: call.localVideoDirection,
      localMediaStream: call.localMediaStream
    };
    return state.mergeIn([`callState`], mediaState);
  }
  case UPDATE_REMOTE_MEDIA: {
    const call = action.payload.call;
    const mediaState = {
      receivingAudio: call.receivingAudio,
      receivingVideo: call.receivingVideo,
      sendingAudio: call.sendingAudio,
      sendingVideo: call.sendingVideo,
      remoteMediaStream: call.remoteMediaStream
    };
    return state.mergeIn([`callState`], mediaState);
  }
  case STORE_CALL:
    return state.set(`call`, action.payload.call);
  case ANSWER_INCOMING_CALL: {
    return state
      .set(`call`, action.payload.call)
      .setIn([`status`, `isRinging`], false)
      .setIn([`incomingCall`, `hasAcknowledged`], false)
      .setIn([`incomingCall`, `call`], null);
  }
  case REMOVE_INCOMING_CALL:
    return state
      .setIn([`status`, `isRinging`], false)
      .setIn([`incomingCall`, `hasAcknowledged`], false)
      .setIn([`incomingCall`, `call`], null);
  case CALL_INCOMING: {
    const incomingCall = action.payload.call;
    return state
      .setIn([`incomingCall`, `hasAcknowledged`], true)
      .setIn([`status`, `isRinging`], true)
      .setIn([`incomingCall`, `call`], incomingCall);
  }
  case CALL_CONNECTED: {
    const call = action.payload.call;
    return state
      .set(`call`, call)
      .setIn([`status`, `isConnected`], true)
      .setIn([`status`, `isDialing`], false)
      .setIn([`callState`, `localMediaStream`], call.localMediaStream)
      .setIn([`callState`, `remoteMediaStream`], call.remoteMediaStream)
      .set(`callStartTime`, Date.parse(call.locus.fullState.lastActive));
  }
  case CALL_DISCONNECTED: {
    const isListening = state.getIn([`status`, `isListening`]);
    const incomingAcknowledged = state.getIn([`incomingCall`, `hasAcknowledged`]);
    const incomingStatus = state.getIn([`status`, `isRinging`]);
    const incomingCall = state.getIn([`incomingCall`, `call`]);
    const webRTCSupported = state.getIn([`webRTC`, `isSupported`]);
    return initialState
      .setIn([`status`, `isListening`], isListening)
      .setIn([`status`, `isRinging`], incomingStatus)
      .setIn([`incomingCall`, `hasAcknowledged`], incomingAcknowledged)
      .setIn([`incomingCall`, `call`], incomingCall)
      .setIn([`webRTC`, `isCheckingSupport`], false)
      .setIn([`webRTC`, `isSupported`], webRTCSupported);
  }
  case CHECKING_WEBRTC_SUPPORT:
    return state.setIn([`webRTC`, `isCheckingSupport`], action.payload.status);
  case UPDATE_WEBRTC_SUPPORT:
    return state.setIn([`webRTC`, `isSupported`], action.payload.supported);
  default:
    return state;
  }
}
