export const SET_ERROR = `presence/SET_ERROR`;
export const SET_USER_PRESENCE_STATUS = `presence/SET_USER_PRESENCE_STATUS`;
export const UPDATE_MODULE_STATUS = `presence/UPDATE_MODULE_STATUS`;
export const UPDATE_USER_STATUS_ERROR = `presence/UPDATE_USER_STATUS_ERROR`;

function updateStatus(status) {
  return {
    type: UPDATE_MODULE_STATUS,
    payload: {
      status
    }
  };
}

function setError(error) {
  return {
    type: SET_ERROR,
    payload: {
      error
    }
  };
}

function setUserPresenceStatus(status) {
  return {
    type: SET_USER_PRESENCE_STATUS,
    payload: {
      status
    }
  };
}

// active: Indicates that the user is "active" in the system for the given ttl or until another event is received.
// inactive: Indicates that the user should be considered "inactive" for the given ttl or until another event is received
// dnd: Indicates a desire by the user to not be disturbed for the given ttl.A TTL= 0 indicates canceling current dnd state
// ooo: Indicates that the user is "out of office" for the given ttl.A TTL= 0 indicates canceling current ooo state
/**
 * @type {('active', 'inactive', 'dnd', 'ooo')} EventType - Types of user statuses
 */

/**
 * Sets a given user's status
 * @param {string} userId
 * @param {EventType} eventType
 * @param {number} ttl Time To Live for the event in seconds.
 * @param {object} spark
 * @returns {Thunk}
 */
export function setUserStatus(userId, eventType, ttl, spark) {
  return (dispatch) => {
    dispatch(updateStatus({isSettingUserStatus: true}));
    return spark.request({
      method: `POST`,
      api: `apheleia`,
      resource: `events`,
      body: {
        subject: userId,
        eventType,
        ttl
      }
    })
/**
* Response Data:
* {
*   eventType: "dnd"
*   expires: "2017-06-02T19:09:51.373Z"
*   expiresTTL: 119
*   subject: "SUBJECT-ID"
* }
*/
      .then(() =>
        dispatch(updateStatus({isSettingUserStatus: false}))
      )
      .catch((error) =>
        dispatch(setError(error))
      );
  };
}

/**
 * Async requests a specific user's status
 * @param {array | string} userIds
 * @param {object} spark
 * @returns {Thunk}
 */
/**
 * Response.body
 * {
 *   "statusList": [
 *      {
 *        "url":"https://apheleia-a.wbx2.com/apheleia/api/v1?userId=THE-USER-ID",
 *        "subject":"THE-USER-ID",
 *        "status":"active",
 *        "statusTime":"2017-06-02T19:38:16.029Z",
 *        "lastActive":"2017-06-02T19:43:25.490Z",
 *        "expiresTTL":357,
 *        "vectorCounters":{"sourceDC":"a1","counters":{"a1":12644,"a2":13}},
 *        "suppressNotifications":false,
 *        "lastSeenDeviceUrl":"https://wdm-a.wbx2.com/wdm/api/v1/devices/THE-DEVICE-ID",
 *        "expires":"2017-06-02T19:53:25.490Z","expiresTime":"2017-06-02T19:53:25.490Z"
 *      }
 *    ]
 * }
 */
export function getCurrentStatus(userIds, spark) {
  const subjects = Array.isArray(userIds) ? userIds : [userIds];
  return (dispatch) =>
    spark.request({
      method: `POST`,
      api: `apheleia`,
      resource: `compositions`,
      body: {subjects}
    })
      .then((response) => {
        const currentStatus = response.body.statusList;
        return dispatch(setUserPresenceStatus(currentStatus));
      });
}

/**
 * Fetches and subscribes to a user's presence status
 * @param {array | string} userIds
 * @param {object} spark
 * @returns {Thunk}
 */
export function subscribeToUpdates(userIds, spark) {
  const subjects = Array.isArray(userIds) ? userIds : [userIds];
  return (dispatch) => {
    dispatch(updateStatus({isSubscribingToUpdates: true}));
    // normal subscription ttl in seconds
    const subscriptionTtl = 600;
    return spark.request({
      method: `POST`,
      api: `apheleia`,
      resource: `subscriptions`,
      body: {
        subjects,
        subscriptionTtl,
        includeStatus: true
      }
    })
      .then((response) => {
        spark.internal.mercury.on(`event:apheleia.subscription_update`, (event) => {
          dispatch(setUserPresenceStatus(prepareSingleStatusResponse(event.data)));
        });
        dispatch(setUserPresenceStatus(prepareStatusResponses(response.body.responses)));
        return dispatch(updateStatus({isSubscribedToUpdates: true}));
      });
  };
}

/**
 * Tells the service to stop sending status updates
 * @param {array | string} userIds
 * @param {object} spark
 * @returns {Thunk}
 */
export function unsubscribeFromUpdates(userIds, spark) {
  const subjects = Array.isArray(userIds) ? userIds : [userIds];
  return (dispatch) =>
    spark.request({
      method: `POST`,
      api: `apheleia`,
      resource: `subscriptions`,
      body: {
        subjects,
        subscriptionTtl: 0,
        includeStatus: true
      }
    })
      .then(() => {
        spark.internal.mercury.off(`event:apheleia.subscription_update`);
        return dispatch(updateStatus({isSubscribedToUpdates: false}));
      });
}

function prepareStatusResponses(responses) {
  // Convert array of responses to an object
  const processed = {};
  responses.forEach((response) => {
    if (!response.subject) {
      return;
    }
    processed[response.subject] = response.status;
  });
  return processed;
}

function prepareSingleStatusResponse(response) {
  const processed = {};
  processed[response.subject] = response;
  return processed;
}
