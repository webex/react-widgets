import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {autobind} from 'core-decorators';

import {events as metricEvents} from '@ciscospark/react-redux-spark-metrics';
import MessageWidget from '@ciscospark/widget-message';
import MeetWidget from '@ciscospark/widget-meet';
import TitleBar from '@ciscospark/react-component-title-bar';
import Button from '@ciscospark/react-component-button';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import Timer from '@ciscospark/react-component-timer';
import ErrorDisplay from '@ciscospark/react-component-error-display';

import {fetchCurrentUser} from '@ciscospark/redux-module-user';
import {connectToMercury} from '@ciscospark/redux-module-mercury';
import {addError, removeError} from '@ciscospark/redux-module-errors';
import {
  ICON_TYPE_MESSAGE_OUTLINE,
  ICON_TYPE_VIDEO_OUTLINE,
  ICON_TYPE_WAFFLE
} from '@ciscospark/react-component-icon';

import ActivityMenu from './components/activity-menu';

import {
  getSpaceDetails,
  updateActivityType,
  storeActivityTypes,
  storeToPerson,
  storeSpaceDetails,
  toggleActivityMenuVisible
} from './actions';
import messages from './messages';
import {getSpaceWidgetProps} from './selector';
import styles from './styles.css';
import {eventNames} from './events';

const DEFAULT_ACTIVITY_TYPES = [
  {
    displayName: `Message`,
    name: `message`,
    buttonClassName: styles.messageButton,
    iconClassName: ICON_TYPE_MESSAGE_OUTLINE,
    component: MessageWidget,
    spaceTypes: [`group`, `direct`]
  },
  {
    displayName: `Call`,
    name: `meet`,
    buttonClassName: styles.meetButton,
    iconClassName: ICON_TYPE_VIDEO_OUTLINE,
    component: MeetWidget,
    spaceTypes: [`direct`]
  }
];

const DEFAULT_ACTIVITY = `message`;


export class SpaceWidget extends Component {

  constructor(props) {
    super(props);
    // Store activity types used in widget
    let activityTypes = DEFAULT_ACTIVITY_TYPES;
    if (typeof props.customActivityTypes === `object`) {
      activityTypes = activityTypes.concat(props.customActivityTypes);
    }
    props.storeActivityTypes(activityTypes);

    if (props.toPersonEmail || props.toPersonId) {
      props.storeToPerson(props.toPersonEmail || props.toPersonId);
    }
  }

  componentWillMount() {
    const props = this.props;
    this.setup(props);
  }

  componentWillReceiveProps(nextProps) {
    const {
      call,
      spaceDetails,
      activityTypes,
      initialActivity
    } = nextProps;
    this.setup(nextProps);
    const props = this.props;
    const prevCall = props.call;
    // Switch to Meet if ringing
    if (call && !prevCall) {
      nextProps.updateActivityType(`meet`);
    }

    // Reset back to message view after call ends
    if (prevCall && prevCall.getIn([`callState`, `connected`])
      && (!call || !call.getIn([`callState`, `connected`]))) {
      nextProps.updateActivityType(`message`);
    }

    // Set the initial activity once we get space details
    if (!props.spaceDetails && spaceDetails) {
      if (activityTypes.find((a) => a.name === initialActivity)) {
        props.updateActivityType(initialActivity);
      }
      else {
        props.updateActivityType(DEFAULT_ACTIVITY);
      }
    }

    this.checkForMercuryErrors(nextProps);

  }

  shouldComponentUpdate(nextProps) {
    return nextProps !== this.props;
  }

  componentWillUnmount() {
    this.props.removeWidget();
  }

  @autobind
  setup(props) { // eslint-disable-line complexity
    const {
      conversation,
      errors,
      spaceId,
      sparkInstance,
      sparkState,
      spark,
      toPersonEmail,
      toPersonId,
      mercury,
      metrics,
      user,
      spaceDetails,
      widgetSpace,
      widgetStatus
    } = props;

    const registerErrorId = `spark.register`;
    const toPerson = widgetSpace.get(`toPerson`);
    if (sparkState.get(`registerError`) && (!errors.get(`hasError`) || !errors.get(`errors`).has(registerErrorId))) {
      const {formatMessage} = props.intl;
      const error = spark.get(`error`);
      const displayTitle = formatMessage(messages.unableToLoad);
      let displaySubtitle = formatMessage(messages.unknownError);
      if (error.statusCode === 401) {
        displaySubtitle = formatMessage(messages.errorBadToken);
      }
      props.addError({
        id: registerErrorId,
        displayTitle,
        displaySubtitle,
        temporary: false,
        code: error.statusCode
      });
    }

    else if (sparkInstance && sparkState.get(`authenticated`) && sparkState.get(`registered`) && !sparkState.get(`hasError`)) {
      // Get current user details
      if (!user.getIn([`status`, `isFetchingCurrentUser`]) && !user.get(`currentUser`)) {
        props.fetchCurrentUser(sparkInstance);
      }
      if (!widgetStatus.get(`isFetchingSpaceDetails`) && !errors.get(`hasError`) && !spaceDetails) {
        if (spaceId) {
          props.getSpaceDetails(sparkInstance, spaceId, props.intl);
        }
        // Hack until we find a way to get a one-on-one space's details before loading conversation
        else if (toPersonEmail || toPersonId) {
          props.storeSpaceDetails({
            type: `direct`
          });
        }
      }


      const toSelfErrorId = `space.error.toSelf`;
      if (toPerson && user.get(`currentUser`) && (!errors.get(`hasError`) || !errors.get(`errors`).has(toSelfErrorId))) {
        // Check for to user being self
        const currentUser = user.get(`currentUser`);
        if ([currentUser.id, currentUser.email].includes(toPerson)) {
          const {formatMessage} = props.intl;
          const displayTitle = formatMessage(messages.unableToLoad);
          const displaySubtitle = formatMessage(messages.errorToSelf);
          props.addError({
            id: toSelfErrorId,
            displayTitle,
            displaySubtitle,
            temporary: false
          });
        }
      }

      // Setup Web Sockets
      if (!mercury.getIn([`status`, `hasConnected`])
        && !mercury.getIn([`status`, `isConnecting`])
        && !mercury.getIn([`status`, `isConnected`])
        && sparkInstance.internal.device.registered) {
        props.connectToMercury(sparkInstance);
      }

      if (conversation.get(`id`)) {
        metrics.sendEndMetric(metricEvents.WIDGET_LOAD);
      }

    }
  }

  @autobind
  handleActivityChange(activity) {
    this.props.updateActivityType(activity);
  }

  @autobind
  handleMenuClick() {
    this.props.toggleActivityMenuVisible();
  }

  checkForMercuryErrors(props) {
    const {
      errors,
      intl,
      mercury
    } = props;
    // Add Mercury disconnect error
    const mercuryError = `mercury.disconnect`;
    const isMercuryConnected = mercury.getIn([`status`, `connected`]);
    const isMercuryDisconnected = !isMercuryConnected && mercury.getIn([`status`, `hasConnected`]);
    const hasError = errors.get(`hasError`);
    const hasMercuryError = errors.get(`errors`).has(mercuryError);
    const hasNoMercuryError = !hasError || !hasMercuryError;
    if (isMercuryDisconnected && hasNoMercuryError) {
      // Create UI Error
      const {formatMessage} = intl;
      props.addError({
        id: mercuryError,
        displayTitle: formatMessage(messages.errorConnection),
        displaySubtitle: formatMessage(messages.reconnecting),
        temporary: true
      });
    }
    if (isMercuryConnected && hasMercuryError) {
      props.removeError(mercuryError);
    }
  }

  /**
   * Builds widget elements from activityTypes list
   *
   * @param {List} activityTypes Immutable List of activity types
   * @param {String} activityType Active activity type
   * @returns Array of Widget elements
   */
  @autobind
  constructActivityWidgets(activityTypes, activityType) {
    return activityTypes.toJS().map((a) => {
      // Only allow widget if it's available for this space type
      const Widget = a.component;
      const isVisible = activityType === a.name ? `` : styles.hidden;
      return (
        <div
          className={classNames(`ciscospark-${a.name}-wrapper`, styles.activityComponentWrapper, isVisible)}
          key={a.name}
        >
          <Widget
            {...this.props}
            eventNames={eventNames}
            injectProvider={false}
            toPerson={this.props.spaceDetails.get(`toPerson`)}
          />
        </div>
      );
    });
  }

  render() {
    const props = this.props;
    const {
      activityTypes,
      media,
      sparkInstance,
      spaceDetails,
      errors,
      widgetSpace,
      widgetStatus
    } = props;

    const {formatMessage} = props.intl;
    let displaySubtitle, displayTitle, errorAction, errorActionTitle, temporary, widgetError;
    if (errors.get(`hasError`)) {
      widgetError = errors.get(`errors`).first();
      errorAction = widgetError.onAction;
      errorActionTitle = widgetError.actionTitle;
      displayTitle = widgetError.displayTitle;
      displaySubtitle = widgetError.displaySubtitle;
      temporary = widgetError.temporary;
    }
    if (sparkInstance && spaceDetails) {
      // Construct widgets
      const activityType = widgetSpace.get(`activityType`);
      const widgets = this.constructActivityWidgets(activityTypes, activityType);
      const spaceTitle = spaceDetails.get(`title`) || `Loading...`;
      const spaceAvatar = typeof spaceDetails.get(`avatar`) === `string` ? spaceDetails.get(`avatar`) : undefined;
      const callStartTime = media.get(`callStartTime`);
      return (
        <div className={classNames(`ciscospark-space-widget`, styles.spaceWidget)}>
          {
            errors.get(`hasError`) &&
            <div className={classNames(`ciscospark-error-wrapper`, styles.errorWrapper)}>
              <ErrorDisplay
                actionTitle={errorActionTitle}
                onAction={errorAction}
                secondaryTitle={displaySubtitle}
                title={displayTitle}
                transparent={temporary}
              />
            </div>
          }
          {
            widgetStatus.get(`activityMenuVisible`) &&
            <div className={classNames(`ciscospark-activity-menu-wrapper`, styles.activityMenuWrapper)}>
              <ActivityMenu
                activityTypes={activityTypes}
                onChange={this.handleActivityChange}
                onExit={this.handleMenuClick}
              />
            </div>
          }
          <div className={classNames(`ciscospark-title-bar-wrapper`, styles.titleBarWrapper)}>
            <TitleBar image={spaceAvatar} name={spaceTitle}>
              {
                callStartTime &&
                <div className={classNames(`ciscospark-title-bar-call-timer`, styles.callTimer)}>
                  <Timer startTime={callStartTime} />
                </div>
              }
              <div className={classNames(`ciscospark-activity-menu-button-wrapper`, styles.activityMenuButtonWrapper)}>
                <div className={classNames(`ciscospark-activity-menu-button`, styles.activityMenuButton)}>
                  <Button accessibilityLabel={`Main Menu`} iconType={ICON_TYPE_WAFFLE} onClick={this.handleMenuClick} />
                </div>
              </div>
            </TitleBar>
          </div>
          <div className={classNames(`ciscospark-widget-body`, styles.widgetBody)}>
            {widgets}
          </div>
        </div>
      );
    }
    else if (errors.get(`hasError`)) {
      return (
        <div className={classNames(`ciscospark-space-widget`, styles.spaceWidget)}>
          <ErrorDisplay
            actionTitle={errorActionTitle}
            onAction={errorAction}
            secondaryTitle={displaySubtitle}
            title={displayTitle}
            transparent={temporary}
          />
        </div>
      );
    }

    return <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />;
  }
}

const injectedPropTypes = {
  activityTypes: PropTypes.object,
  conversation: PropTypes.object,
  errors: PropTypes.object,
  media: PropTypes.object,
  mercury: PropTypes.object,
  sparkInstance: PropTypes.object,
  user: PropTypes.object,
  widgetSpace: PropTypes.object,
  addError: PropTypes.func,
  connectToMercury: PropTypes.func,
  getSpaceDetails: PropTypes.func,
  removeError: PropTypes.func,
  storeActivityTypes: PropTypes.func,
  storeSpaceDetails: PropTypes.func,
  toggleActivityMenuVisible: PropTypes.func,
  updateActivityType: PropTypes.func,
  call: PropTypes.object
};

export const ownPropTypes = {
  customActivityTypes: PropTypes.object,
  initialActivity: PropTypes.string,
  muteNotifications: PropTypes.bool,
  spaceId: PropTypes.string,
  startCall: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.bool
  ]),
  toPersonEmail: PropTypes.string,
  toPersonId: PropTypes.string
};

SpaceWidget.propTypes = {
  ...injectedPropTypes,
  ...ownPropTypes
};

SpaceWidget.defaultProps = {
  initialActivity: DEFAULT_ACTIVITY
};

function mapStateToProps(state, props) {
  return getSpaceWidgetProps(state, props);
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    addError,
    connectToMercury,
    getSpaceDetails,
    fetchCurrentUser,
    getSpaceWidgetProps,
    removeError,
    storeActivityTypes,
    storeSpaceDetails,
    storeToPerson,
    toggleActivityMenuVisible,
    updateActivityType
  }, dispatch)
)(SpaceWidget);
