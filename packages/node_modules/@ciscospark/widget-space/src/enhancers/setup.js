import {compose, lifecycle} from 'recompose';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';

import {fetchAvatar} from '@ciscospark/redux-module-avatar';
import {resetErrors} from '@ciscospark/redux-module-errors';
import {connectToMercury} from '@ciscospark/redux-module-mercury';
import {fetchSpace} from '@ciscospark/redux-module-spaces';
import {getUser} from '@ciscospark/redux-module-users';
import {validateAndDecodeId} from '@ciscospark/react-component-utils';

import {
  getSpaceDetails,
  reloadWidget,
  storeDestination,
  updateWidgetStatus
} from '../actions';

import {getSpaceWidgetProps} from '../selector';

import {destinationTypes} from '../';

function setup(props, prevProps) {
  const {
    conversation,
    destination,
    errors,
    sparkInstance,
    sparkState,
    spaceDetails,
    widgetStatus,
    mercuryStatus,
    users,
    spaces
  } = props;

  if (sparkInstance
    && sparkState.get('authenticated')
    && sparkState.get('registered')
    && !sparkState.get('hasError')
  ) {
    // Check if we need to reload space
    if (widgetStatus.shouldReloadWidget && prevProps && !prevProps.widgetStatus.shouldReloadWidget) {
      props.reloadWidget();
      props.resetErrors();
    }

    // Check for destination Change
    if (destination && prevProps.destination) {
      const previousDestination = prevProps.destination;

      if (
        destination.id !== previousDestination.id
        || destination.type !== previousDestination.type
      ) {
        sparkInstance.logger.info('Destination has changed, widget reloading...');
        props.updateWidgetStatus({
          shouldReloadWidget: true
        });
      }
    }

    // Connect to websocket (mercury)
    if (!mercuryStatus.hasConnected
      && !mercuryStatus.connecting
      && !mercuryStatus.connected
      && sparkInstance.internal.device.registered) {
      props.connectToMercury(sparkInstance);
    }

    // Get space details for given destination
    if (!widgetStatus.isFetchingSpaceDetails && !errors.get('hasError') && !spaceDetails) {
      // If the selector isn't returning a destination object and we have props for them, store
      if (destination) {
        // Use destination object from store to fetch space details
        props.getSpaceDetails({
          sparkInstance,
          destinationId: destination.id,
          destinationType: destination.type,
          intl: props.intl
        });
        // Fetch 1:1 User details
        if (destination.type === destinationTypes.EMAIL && !users.getIn(['byEmail', destination.id])) {
          props.getUser({email: destination.id}, sparkInstance);
        }
        if (destination.type === destinationTypes.USERID && !users.getIn(['byId', destination.id])) {
          props.getUser({id: destination.id}, sparkInstance);
        }
        if (destination.type === destinationTypes.SPACEID && !spaces.getIn(['byId', validateAndDecodeId(destination.id)])) {
          props.fetchSpace(sparkInstance, validateAndDecodeId(destination.id));
        }
      }
      else {
        // Destination has not been stored yet, process and store.
        const {
          destinationId,
          destinationType
        } = props;

        props.storeDestination({
          type: destinationType,
          id: destinationId
        });
      }
    }

    if (conversation.get('id')) {
      props.fetchAvatar({space: conversation.toJS()}, sparkInstance);
    }
  }
}

export default compose(
  connect(
    getSpaceWidgetProps,
    (dispatch) => bindActionCreators({
      connectToMercury,
      fetchSpace,
      getUser,
      getSpaceDetails,
      reloadWidget,
      resetErrors,
      storeDestination,
      updateWidgetStatus,
      fetchAvatar
    }, dispatch)
  ),
  lifecycle({
    componentWillMount() {
      setup(this.props);
    },
    shouldComponentUpdate(nextProps) {
      return nextProps !== this.props;
    },
    componentWillReceiveProps(nextProps) {
      setup(nextProps, this.props);
    }
  })
);
