import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import classNames from 'classnames';
import {autobind} from 'core-decorators';

import LoadingScreen from '@ciscospark/react-component-loading-screen';
import Spinner from '@ciscospark/react-component-spinner';
import ErrorDisplay from '@ciscospark/react-component-error-display';

import {addError, removeError} from '@ciscospark/redux-module-errors';
import {fetchCurrentUser} from '@ciscospark/redux-module-user';
import {
  acknowledgeSpace,
  fetchSpace,
  hideSpace,
  removeSpace,
  fetchSpaces,
  updateSpaceWithActivity,
  updateSpaceRead
} from '@ciscospark/redux-module-spaces';
import {fetchAvatar} from '@ciscospark/redux-module-avatar';
import {fetchTeams} from '@ciscospark/redux-module-teams';
import {events as metricEvents} from '@ciscospark/react-redux-spark-metrics';
import {connectToMercury} from '@ciscospark/redux-module-mercury';
import IncomingCall from '@ciscospark/react-component-incoming-call';

import messages from './messages';
import {getRecentsWidgetProps} from './selector';
import {
  updateWidgetStatus,
  updateWebRTCSupport,
  storeIncomingCall,
  deleteIncomingCall,
  updateVisibilityCount
} from './actions';
import SpacesList from './components/spaces-list';
import styles from './styles.css';
import {
  eventNames,
  constructMessagesEventData,
  constructRoomsEventData,
  constructMembershipEventData,
  constructCallEventData
} from './events';


export class RecentsWidget extends Component {

  componentWillReceiveProps(nextProps) {
    this.checkForMercuryErrors(nextProps);
    this.setup(nextProps);
    this.addListeners(nextProps);
    this.fetchAllAvatars(nextProps);
  }

  shouldComponentUpdate(nextProps) {
    return nextProps.spacesList !== this.props.spacesList
      || nextProps.mercury !== this.props.mercury
      || nextProps.errors !== this.props.errors
      || nextProps.user !== this.props.user
      || nextProps.widgetRecents !== this.props.widgetRecents;
  }

  componentWillUnmount() {
    this.props.removeWidget();
  }

  @autobind
  setup(props) { // eslint-disable-line complexity
    const {
      errors,
      spark,
      sparkInstance,
      sparkState,
      mercury,
      metrics,
      user,
      spaces,
      teams,
      widgetRecents
    } = props;

    // Check for spark device errors (auth)
    const registerErrorId = `spark.register`;
    if (sparkState.get(`registerError`) && (!errors.get(`hasError`) || !errors.get(`errors`).has(registerErrorId))) {
      const {formatMessage} = props.intl;
      const error = spark.get(`error`);
      const displayTitle = formatMessage(messages.unableToLoad);
      let displaySubtitle = formatMessage(messages.unknownError);
      if (error.statusCode === 401) {
        displaySubtitle = formatMessage(messages.errorBadToken);
      }
      props.addError({
        id: registerErrorId,
        displayTitle,
        displaySubtitle,
        temporary: false,
        code: error.statusCode
      });
    }

    else if (sparkInstance && sparkState.get(`authenticated`) && sparkState.get(`registered`)) {
      // Get current user details
      if (!user.getIn([`status`, `isFetchingCurrentUser`]) && !user.get(`currentUser`)) {
        props.fetchCurrentUser(sparkInstance);
      }

      // Setup Web Sockets
      if (!mercury.getIn([`status`, `hasConnected`])
        && !mercury.getIn([`status`, `connecting`])
        && !mercury.getIn([`status`, `connected`])
        && sparkInstance.internal.device.registered) {
        props.connectToMercury(sparkInstance);
      }

      if (mercury.getIn([`status`, `connected`])) {
        // Grab spaces
        if (!spaces.getIn([`status`, `isFetching`])
          && !spaces.getIn([`status`, `hasFetched`])) {
          props.fetchSpaces(sparkInstance);
        }

        // Grab teams
        if (!teams.getIn([`status`, `isFetching`])
          && !teams.getIn([`status`, `hasFetched`])) {
          props.fetchTeams(sparkInstance);
        }
      }

      if (sparkInstance && sparkInstance.phone && !widgetRecents.getIn([`status`, `hasCheckedWebRTCSupport`])) {
        props.updateWidgetStatus({hasCheckedWebRTCSupport: true});
        sparkInstance.phone.isCallingSupported().then((supported) => {
          props.updateWebRTCSupport(supported);
        });
      }

    }
    if (spaces.getIn([`status`, `hasFetched`])) {
      metrics.sendEndMetric(metricEvents.WIDGET_LOAD);
    }
  }

  @autobind
  fetchAllAvatars(nextProps) {
    const {
      user,
      spaces,
      spacesList,
      sparkInstance
    } = nextProps;

    if (user.get(`currentUser`)
      && spaces.getIn([`status`, `hasFetched`])
      && this.props.spacesList
      && spacesList.count() > this.props.spacesList.count()
      || !spaces.getIn([`status`, `isDecrypting`])
      && this.props.spaces.getIn([`status`, `isDecrypting`])
    ) {
      spacesList.forEach((s) => {
        if (!s.isDecrypting) {
          if (s.type === `direct`
            && s.participants.length > 1
            && s.toPersonId
          ) {
            nextProps.fetchAvatar({userId: s.toPersonId}, sparkInstance);
          }
          else if (spaces.hasIn([`items`, s.id])) {
            nextProps.fetchAvatar({space: spaces.getIn([`items`, s.id]).toJS()}, sparkInstance);
          }
        }
      });
    }
  }

  @autobind
  addListeners(nextProps) {
    const {
      user,
      spaces,
      sparkInstance,
      widgetRecents
    } = nextProps;

    if (user.get(`currentUser`)
      && spaces.getIn(`status`, `hasFetched`)
      && !widgetRecents.getIn([`status`, `isListeningForNewActivity`])
    ) {
      this.listenForNewActivity(sparkInstance, nextProps);
      this.listenForCall(sparkInstance, nextProps);
    }
  }

  @autobind
  handleShowMoreSpaces() {
    const {
      widgetRecents
    } = this.props;
    this.props.updateVisibilityCount(widgetRecents.get(`visibilityCount`) + 15);
  }

  @autobind
  handleNewActivity(activity) {
    const {
      props
    } = this;
    const {
      sparkInstance,
      spacesList
    } = props;

    let spaceId = activity.target && activity.target.id;

    // Handle spaceId if this is a completely new space or hiding a space
    if (!spaceId && [`create`, `hide`].includes(activity.verb)) {
      spaceId = activity.object.id;
    }

    const space = spacesList.get(spaceId);

    const processActivity = this.processActivity;
    if (space) {
      processActivity(activity, space);
    }
    else {
      // go retrieve the space if it doesn't exist
      props.fetchSpace(sparkInstance, spaceId)
        .then((newSpace) => {
          if (newSpace) {
            processActivity(activity, newSpace);
          }
        });
    }
  }

  @autobind
  processActivity(activity, space) { // eslint-disable-line complexity
    const {props, handleEvent} = this;
    const {
      user
    } = props;
    const currentUser = user.get(`currentUser`);
    const isSelf = activity.actor.id === currentUser.id;
    switch (activity.verb) {
    case `share`:
    case `post`: {
      const currentUserEmail = currentUser.email;
      const otherUser = space.participants
        .find((p) => p.emailAddress !== currentUserEmail);

      // Update space with newest post activity
      props.updateSpaceWithActivity(activity, isSelf, true);

      // Do not emit unread if current user created the message
      if (!isSelf) {
        handleEvent(eventNames.SPACES_UNREAD, constructRoomsEventData(space, activity));
      }
      // Emit message:created event
      handleEvent(eventNames.MESSAGES_CREATED, constructMessagesEventData(activity, otherUser));
      break;
    }
    case `lock`:
    case `unlock`: {
      props.updateSpaceWithActivity(activity, isSelf);
      break;
    }
    case `acknowledge`: {
      if (isSelf) {
        // update space with last acknowledgment if it's this user
        props.updateSpaceRead(activity.target.id, activity.published);
        handleEvent(eventNames.SPACES_READ, constructRoomsEventData(space, activity));
      }
      break;
    }
    case `create`: {
      const constructedActivity = Object.assign({}, activity, {
        target: activity.object,
        object: {
          id: currentUser.id,
          emailAddress: currentUser.email
        }
      });
      handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(constructedActivity));
      break;
    }
    case `add`: {
      handleEvent(eventNames.MEMBERSHIPS_CREATED, constructMembershipEventData(activity));
      break;
    }
    case `leave`: {
      props.removeSpace(space.id);
      handleEvent(eventNames.MEMBERSHIPS_DELETED, constructMembershipEventData(activity));
      break;
    }
    case `hide`: {
      props.removeSpace(space.id);
      break;
    }
    default:
    }
  }

  /**
   * Setup listeners for new activities
   *
   * @param {Object} sparkInstance
   * @param {Object} props
   * @returns {Promise}
   */
  listenForNewActivity(sparkInstance, props) {
    props.updateWidgetStatus({isListeningForNewActivity: true});
    return sparkInstance.internal.mercury.on(`event:conversation.activity`, (event) => this.handleNewActivity(event.data.activity));
  }

  /**
   * Setup listeners for call activities
   *
   * @param {Object} sparkInstance
   * @param {Object} props
   * @returns {Promise}
   */
  listenForCall(sparkInstance, props) {
    props.updateWidgetStatus({isListeningForCall: true});
    return sparkInstance.phone.on(`call:incoming`, (call) => this.handleCall(call));
  }

  @autobind
  getSpaceFromCall(call) {
    return this.props.spacesList.get(call.locus.conversationUrl.split(`/`).pop());
  }

  @autobind
  handleCall(call) {
    const {
      props,
      handleEvent
    } = this;
    const {
      spacesList
    } = props;

    const space = spacesList.get(call.locus.conversationUrl.split(`/`).pop());
    // Only provide event if the call is direct
    if (space.type === `direct`) {
      call.acknowledge()
        .then(() => {
          const removeIncoming = () => call.hangup().then(props.deleteIncomingCall);
          // If call signals Disconnect we fire hangup and clean up
          call.once(`disconnected`, () => removeIncoming);
          // If call signals Connect we clean up
          call.once(`connected`, () => {
            call.off(`disconnected`, removeIncoming);
            props.deleteIncomingCall();
          });
          props.storeIncomingCall(call);

          handleEvent(eventNames.CALLS_CREATED, constructCallEventData(call, space));
        });
    }
  }

  @autobind
  handleAnswer() {
    const space = this.getSpaceFromCall(this.props.widgetRecents.get(`incomingCall`));
    this.handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL_ANSWER,
      ...constructRoomsEventData(space)
    });
    this.props.deleteIncomingCall();
  }

  @autobind
  handleDecline() {
    const {
      props,
      getSpaceFromCall,
      handleEvent
    } = this;
    const call = props.widgetRecents.get(`incomingCall`);
    const space = getSpaceFromCall(call);

    call.reject()
      .then(() => {
        handleEvent(eventNames.SPACES_SELECTED, {
          action: eventNames.ACTION_CALL_REJECT,
          ...constructRoomsEventData(space)
        });
        props.deleteIncomingCall();
      });
  }

  @autobind
  handleSpaceClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    this.handleEvent(eventNames.SPACES_SELECTED, constructRoomsEventData(space));
  }

  @autobind
  handleSpaceCallClick(spaceId) {
    const space = this.props.spacesList.get(spaceId);
    const roomData = constructRoomsEventData(space);
    this.handleEvent(eventNames.SPACES_SELECTED, {
      action: eventNames.ACTION_CALL,
      ...roomData
    });
  }


    /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undefined}
   */
  @autobind
  handleEvent(name, data) {
    const {
      onEvent,
      sparkInstance
    } = this.props;
    const logData = Object.assign({}, data);
    // Omit call objet from logger to prevent call range error
    if (data.call) {
      logData.call = `--- OMITTED ---`;
    }
    sparkInstance.logger.info(`event handler - ${name} - ${data.action}`, logData);
    if (typeof onEvent === `function`) {
      this.props.onEvent(name, data);
    }
  }

  checkForMercuryErrors(props) {
    const {
      errors,
      intl,
      mercury
    } = props;
    // Add Mercury disconnect error
    const mercuryError = `mercury.disconnect`;
    const isMercuryConnected = mercury.getIn([`status`, `connected`]);
    const isMercuryDisconnected = !isMercuryConnected && mercury.getIn([`status`, `hasConnected`]);
    const hasError = errors.get(`hasError`);
    const hasMercuryError = errors.get(`errors`).has(mercuryError);
    const hasNoMercuryError = !hasError || !hasMercuryError;
    if (isMercuryDisconnected && hasNoMercuryError) {
      // Create UI Error
      const {formatMessage} = intl;
      props.addError({
        id: mercuryError,
        displayTitle: formatMessage(messages.errorConnection),
        displaySubtitle: formatMessage(messages.reconnecting),
        temporary: true
      });
    }
    if (isMercuryConnected && hasMercuryError) {
      props.removeError(mercuryError);
    }
  }

  render() {
    const props = this.props;
    const {
      errors,
      spacesList,
      spaces,
      widgetRecents
    } = props;
    const {formatMessage} = props.intl;
    const isFetchingSpaces = spaces.getIn([`status`, `isFetching`]);
    const hasFetchedSpaces = spaces.getIn([`status`, `hasFetched`]);

    const hasMoreSpaces = spacesList.count() < spaces.get(`items`).count();
    const isShowingMoreSpaces = widgetRecents.get(`visibilityCount`) > spaces.get(`items`).count();
    const showLoader = isFetchingSpaces && isShowingMoreSpaces;
    const showMoreButton = (isFetchingSpaces || hasMoreSpaces) && !isShowingMoreSpaces;

    const incomingCall = widgetRecents.get(`incomingCall`);
    const hasWebRTCSupport = widgetRecents.getIn([`status`, `hasWebRTCSupport`]);
    let displaySubtitle, displayTitle, temporary, widgetError;
    if (errors.get(`hasError`)) {
      widgetError = errors.get(`errors`).first();
      displayTitle = widgetError.displayTitle;
      displaySubtitle = widgetError.displaySubtitle;
      temporary = widgetError.temporary;
    }

    if (spacesList && hasFetchedSpaces) {

      if (incomingCall && hasWebRTCSupport) {
        const space = spacesList.get(incomingCall.locus.conversationUrl.split(`/`).pop());
        return (
          <div className={classNames(`ciscospark-recents-widget`, styles.recentsWidget)}>
            <IncomingCall
              answerButtonLabel={formatMessage(messages.answerButtonLabel)}
              avatarImage={space.avatarUrl}
              declineButtonLabel={formatMessage(messages.declineButtonLabel)}
              displayName={space.name}
              incomingCallMessage={formatMessage(messages.incomingCallMessage)}
              onAnswerClick={this.handleAnswer}
              onDeclineClick={this.handleDecline}
            />
          </div>
        );
      }
      const handleCallClick = hasWebRTCSupport ? this.handleSpaceCallClick : undefined;
      return (
        <div className={classNames(`ciscospark-recents-widget`, styles.recentsWidget)}>
          {
            errors.get(`hasError`) &&
            <div className={classNames(`ciscospark-error-wrapper`, styles.errorWrapper)}>
              <ErrorDisplay
                secondaryTitle={displaySubtitle}
                title={displayTitle}
                transparent={temporary}
              />
            </div>
          }
          <div className={classNames(`ciscospark-spaces-list-wrapper`, styles.spacesListWrapper)}>
            <SpacesList
              formatMessage={formatMessage}
              onCallClick={handleCallClick}
              onClick={this.handleSpaceClick}
              spaces={spacesList}
            />
            {
              showMoreButton &&
              <div className={styles.loadMoreContainer}>
                <button className={styles.loadMoreButton} onClick={this.handleShowMoreSpaces}>
                  {formatMessage(messages.viewOlderSpacesButtonLabel)}
                </button>
              </div>
            }
            {
              showLoader &&
              <div className={styles.spinner}>
                <Spinner bright />
              </div>
            }
          </div>
        </div>
      );
    }
    else if (errors.get(`hasError`)) {
      return (
        <div className={classNames(`ciscospark-recents-widget`, styles.recentsWidget)}>
          <ErrorDisplay
            secondaryTitle={displaySubtitle}
            title={displayTitle}
            transparent={temporary}
          />
        </div>
      );
    }

    return (
      <div className={classNames(`ciscospark-recents-widget`, styles.recentsWidget)}>
        <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />
      </div>
    );
  }
}

const injectedPropTypes = {
  errors: PropTypes.object,
  eventNames: PropTypes.object,
  mercury: PropTypes.object,
  metrics: PropTypes.object,
  spaces: PropTypes.object,
  spacesList: PropTypes.object,
  sparkInstance: PropTypes.object,
  user: PropTypes.object,
  teams: PropTypes.object,
  widgetRecents: PropTypes.object,
  addError: PropTypes.func,
  connectToMercury: PropTypes.func,
  fetchAvatar: PropTypes.func,
  removeError: PropTypes.func,
  updateWidgetStatus: PropTypes.func
};

export const ownPropTypes = {
  muteNotifications: PropTypes.bool
};

RecentsWidget.propTypes = {
  ...injectedPropTypes,
  ...ownPropTypes
};


function mapStateToProps(state) {
  return getRecentsWidgetProps(state);
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    acknowledgeSpace,
    addError,
    connectToMercury,
    fetchCurrentUser,
    fetchSpace,
    fetchAvatar,
    hideSpace,
    removeError,
    removeSpace,
    fetchSpaces,
    updateVisibilityCount,
    fetchTeams,
    updateWidgetStatus,
    updateSpaceWithActivity,
    updateSpaceRead,
    storeIncomingCall,
    deleteIncomingCall,
    updateWebRTCSupport
  }, dispatch)
)(RecentsWidget);
