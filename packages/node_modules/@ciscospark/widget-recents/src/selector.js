import {createSelector} from 'reselect';
import moment from 'moment';
import {OrderedMap} from 'immutable';
import {formatDate} from '@ciscospark/react-component-utils';
import {FEATURE_GROUP_CALLING} from '@ciscospark/redux-module-features';

const getWidget = (state) => state.widgetRecents;
const getSpark = (state) => state.spark;
const getCurrentUser = (state, ownProps) => ownProps.currentUser;
const getAvatars = (state) => state.avatar;
const getTeams = (state) => state.teams.get('byId');
const getFeatures = (state) => state.features;
const getSpaces = (state) => state.spaces.get('byId');
const getUsers = (state) => state.users.get('byId');
const getActivities = (state) => state.activities.get('byId');

function sortByNewest(space) {
  return -moment(space.lastReadableActivityDate).format('x');
}

function constructSpace(space) {
  const {
    lastSeenActivityDate,
    lastReadableActivityDate,
    id
  } = space;
  const isUnread = lastSeenActivityDate ? moment(lastSeenActivityDate).isBefore(lastReadableActivityDate) : true;

  return {
    id,
    type: space.type,
    lastActivityTime: formatDate(lastReadableActivityDate),
    lastActivityTimestamp: lastReadableActivityDate,
    name: 'Untitled',
    participants: space.participants,
    published: space.published,
    isLocked: space.tags && space.tags.includes('LOCKED'),
    isUnread,
    isDecrypting: space.isDecrypting
  };
}

function constructOneOnOne({space, currentUser, users}) {
  const thisSpace = constructSpace(space);

  // Get the user ID of the participant that isn't current user
  const toPersonId = space.participants.find((p) => p !== currentUser.id);
  const toPerson = users.get(toPersonId);
  if (toPerson) {
    thisSpace.toPersonId = toPersonId;
    thisSpace.toPersonEmail = toPerson.email;
    thisSpace.name = toPerson.displayName;
  }
  return thisSpace;
}

function constructGroup({space, team}) {
  const {
    id,
    displayName
  } = space;
  const thisSpace = constructSpace(space);
  thisSpace.name = displayName || 'Untitled';
  if (team) {
    thisSpace.teamName = team.displayName;
    thisSpace.teamColor = team.color;
    thisSpace.teamId = team.id;
    if (id === team.generalConversationId) {
      thisSpace.name = 'General';
    }
  }
  return thisSpace;
}

const getRecentSpaces = createSelector(
  [getSpaces, getActivities, getCurrentUser, getUsers, getTeams, getWidget],
  (spaces, activities, currentUser, users, teams, widget) => {
    const {visibilityCount} = widget;
    let recents = new OrderedMap();
    let count = 0;

    spaces.toOrderedMap().sortBy(sortByNewest).some((space) => {
      if (!space.isHidden) {
        const spaceId = space.id;
        const team = teams.get(space.team);
        let constructedSpace;
        if (space.type === 'direct') {
          constructedSpace = constructOneOnOne({space, users, currentUser});
        }
        else {
          constructedSpace = constructGroup({space, team});
        }

        // Get Latest Activity
        const activity = activities.get(space.latestActivity);
        const actorId = activity.actor;
        const actor = users.get(actorId);
        constructedSpace.latestActivity = {
          actorName: actor && actor.displayName ? actor.displayName.split(' ')[0] : '',
          type: activity.verb,
          object: activity.object,
          text: activity.object.displayName,
          actor
        };

        recents = recents.set(spaceId, constructedSpace);
        count += 1;
      }
      if (count >= visibilityCount) {
        return true;
      }
      return false;
    });
    return recents;
  }
);


const getRecentSpacesWithAvatarUrl = createSelector(
  [getRecentSpaces, getAvatars],
  (recentSpaces, avatars) => {
    const avatarItems = avatars.get('items');
    if (avatarItems.count()) {
      return recentSpaces.map((space) => {
        const s = space;
        if (s.type === 'direct') {
          s.avatarUrl = avatarItems.get(s.toPersonId);
        }
        else {
          s.avatarUrl = avatarItems.get(s.id);
        }
        return s;
      });
    }
    return recentSpaces;
  }
);


const getRecentsWidgetProps = createSelector(
  [
    getWidget,
    getRecentSpacesWithAvatarUrl,
    getSpark,
    getFeatures,
    getSpaces
  ],
  (
    widget,
    spacesList,
    spark,
    features,
    spaces
  ) => {
    let lastActivityDate;
    if (spacesList && spacesList.count()) {
      lastActivityDate = spacesList.last().lastActivityTimestamp;
    }
    const hasGroupCalling = features.getIn(['items', FEATURE_GROUP_CALLING]);
    return {
      widgetStatus: widget.status,
      sparkState: spark.get('status'),
      sparkInstance: spark.get('spark'),
      widgetRecents: widget,
      spaces,
      spacesList,
      hasGroupCalling,
      lastActivityDate
    };
  }
);

export default getRecentsWidgetProps;
