import {compose, lifecycle} from 'recompose';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';

import {fetchAvatar} from '@ciscospark/redux-module-avatar';
import {getFeature} from '@ciscospark/redux-module-features';
import {connectToMercury} from '@ciscospark/redux-module-mercury';
import {fetchSpaces} from '@ciscospark/redux-module-spaces';
import {fetchTeams} from '@ciscospark/redux-module-teams';
import {
  FEATURES_GROUP_MESSAGE_NOTIFICATIONS,
  FEATURES_MENTION_NOTIFICATIONS,
  FEATURES_USER
} from '@ciscospark/react-component-utils';

import {updateSpaceTypeFilter, updateWidgetStatus} from '../actions';
import {getSpaceWidgetProps} from '../selector';

function getSpaceAvatar(s, props) {
  const {sparkInstance} = props;

  if (!s.isDecrypting) {
    if (
      s.type === 'direct'
      && s.toPersonId
    ) {
      props.fetchAvatar({userId: s.toPersonId}, sparkInstance);
    }
    else if (
      s.type === 'group' && s.id
    ) {
      props.fetchAvatar({space: s}, sparkInstance);
    }
  }
}

/**
 * Connects to the websocket server (mercury)
 * @param {object} props
 */
function connectWebsocket(props) {
  const {
    sparkInstance,
    mercuryStatus
  } = props;


  if (!mercuryStatus.hasConnected
      && !mercuryStatus.connecting
      && !mercuryStatus.connected
      && sparkInstance.internal.device.registered) {
    props.connectToMercury(sparkInstance);
  }
}

function getFeatures(props) {
  const {
    sparkInstance,
    widgetStatus
  } = props;

  // Initial fetching of group message notification feature
  if (!widgetStatus.hasFetchedGroupMessageNotificationFeature) {
    props.getFeature(FEATURES_USER, FEATURES_GROUP_MESSAGE_NOTIFICATIONS, sparkInstance).then(() => {
      props.updateWidgetStatus({
        hasFetchedGroupMessageNotificationFeature: true
      });
    });
  }

  // Initial Fetching of mention notification feature
  if (!widgetStatus.hasFetchedMentionNotificationFeature) {
    props.getFeature(FEATURES_USER, FEATURES_MENTION_NOTIFICATIONS, sparkInstance).then(() => {
      props.updateWidgetStatus({
        hasFetchedMentionNotificationFeature: true
      });
    });
  }
}

function getTeams(props) {
  const {
    sparkInstance,
    widgetStatus
  } = props;

  // Grab teams
  if (sparkInstance.internal.team
    && !widgetStatus.isFetchingTeams
    && !widgetStatus.hasFetchedTeams) {
    props.updateWidgetStatus({isFetchingTeams: true});
    props.fetchTeams(sparkInstance)
      .then(() => {
        props.updateWidgetStatus({
          isFetchingTeams: false,
          hasFetchedTeams: true
        });
      });
  }
}

function getInitialSpaces(props) {
  const {
    sparkInstance,
    widgetStatus
  } = props;

  if (!widgetStatus.isFetchingInitialSpaces
    && !widgetStatus.hasFetchedInitialSpaces) {
    props.updateWidgetStatus({isFetchingInitialSpaces: true});
    props.fetchSpaces(sparkInstance, {
      limit: props.spaceLoadCount,
      // We don't need activities for the recents widget
      activitiesLimit: 0,
      lastViewableActivityOnly: false,
      // Defer decrypt allows us to show the encrypted spaces in the space list
      // before decrypting. Giving a better UX
      deferDecrypt: true
    })
      .then((encryptedSpaces) => {
        // As the spaces decrypt, get the avatar for them
        const promises = encryptedSpaces.map((s) =>
          s.decryptPromise.then((decryptedSpace) =>
            getSpaceAvatar(decryptedSpace, props)));

        return Promise.all(promises);
      })
      .then(() => props.updateWidgetStatus({
        hasFetchedInitialSpaces: true
      }));
  }
}

function getAllSpaces(props) {
  const {
    sparkInstance,
    widgetStatus
  } = props;

  if (!widgetStatus.isFetchingAllSpaces
    && !widgetStatus.hasFetchedAllSpaces) {
    props.updateWidgetStatus({isFetchingAllSpaces: true});
    props.fetchSpaces(sparkInstance, {
      limit: 250,
      activitiesLimit: 0,
      lastViewableActivityOnly: false
    })
      .then(() => {
        props.updateWidgetStatus({
          hasFetchedAllSpaces: true
        });
      });
  }
}

function getAvatars(props) {
  const {
    spacesList,
    widgetStatus
  } = props;

  if (!widgetStatus.hasFetchedAvatars
    && !widgetStatus.isFetchingAvatars) {
    props.updateWidgetStatus({isFetchingAvatars: true});
    // TODO: Optimize loading order and pause between
    spacesList.forEach((s) => getSpaceAvatar(s, props));

    props.updateWidgetStatus({hasFetchedAvatars: true});
  }
}

export function setup(props) {
  const {
    mercuryStatus,
    sparkInstance,
    sparkState,
    widgetRecents,
    widgetStatus
  } = props;

  // We cannot do anything until the sdk is ready
  if (sparkInstance
    && sparkState.authenticated
    && sparkState.registered
    && !sparkState.hasError
  ) {
    if (!widgetRecents.spaceType) {
      // This prop is saved in the store for space filtering based on space types
      props.updateSpaceTypeFilter(props.spaceTypeFilter);
    }

    getFeatures(props);

    if (!mercuryStatus.connected) {
      connectWebsocket(props);
    }
    else {
      // Initial fetching workflow
      if (!widgetStatus.hasFetchedInitialSpaces) {
        getInitialSpaces(props);
      }
      else if (!widgetStatus.hasFetchedAllSpaces && props.extendedLoad) {
        // Initial spaces have been fetched, load more
        getAllSpaces(props);
      }
      else if (!widgetStatus.hasFetchedAvatars && props.extendedLoad) {
        // All spaces have been fetched, load avatars
        getAvatars(props);
      }

      // Synchronous load of teams (smaller request)
      if (!widgetStatus.hasFetchedTeams) {
        getTeams(props);
      }
    }
  }
}

export default compose(
  connect(
    getSpaceWidgetProps,
    (dispatch) => bindActionCreators({
      connectToMercury,
      fetchAvatar,
      fetchSpaces,
      fetchTeams,
      getFeature,
      updateSpaceTypeFilter,
      updateWidgetStatus
    }, dispatch)
  ),
  lifecycle({
    componentWillMount() {
      setup(this.props);
    },
    shouldComponentUpdate(nextProps) {
      return nextProps !== this.props;
    },
    componentWillReceiveProps(nextProps) {
      setup(nextProps, this.props);
    }
  })
);
