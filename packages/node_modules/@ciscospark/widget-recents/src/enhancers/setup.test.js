import {getSpaceAvatar, setup} from './setup';

describe('widget-recents: enhancers: setup', () => {
  let props;

  beforeEach(() => {
    props = {
      extendedLoad: true,
      mercuryStatus: {
        hasConnected: false,
        connecting: false,
        connected: false
      },
      spacesList: [],
      sparkInstance: {
        internal: {
          device: {
            registered: false
          }
        }
      },
      sparkState: {
        authenticated: false,
        registered: false,
        hasError: false
      },
      users: {
        get: () => 'my-user-id'
      },
      widgetRecents: {
        spaceType: 'all'
      },
      widgetStatus: {
        isFetchingAvatars: false,
        hasFetchedAvatars: false,
        isFetchingInitialSpaces: false,
        hasFetchedInitialSpaces: false,
        isFetchingAllSpaces: false,
        hasFetchedAllSpaces: false,
        hasFetchedGroupMessageNotificationFeature: false,
        hasFetchedMentionNotificationFeature: false
      },
      spacesById: {
        has: jest.fn(() => true),
        get: jest.fn((a) => a)
      },
      // Mocked action creators
      connectToMercury: jest.fn(),
      fetchAvatar: jest.fn(),
      fetchSpaces: jest.fn(() => Promise.resolve()),
      getFeature: jest.fn(() => Promise.resolve()),
      updateWidgetStatus: jest.fn()
    };
  });

  describe('#setup', () => {
    describe('initial state', () => {
      it('does not do anything until spark registration', () => {
        setup(props);

        expect(props.connectToMercury).not.toHaveBeenCalled();
        expect(props.updateWidgetStatus).not.toHaveBeenCalled();
        expect(props.getFeature).not.toHaveBeenCalled();
      });
    });

    describe('after spark registration', () => {
      beforeEach(() => {
        props.sparkState.authenticated = true;
        props.sparkState.registered = true;
        props.sparkInstance.internal.device.registered = true;
      });

      it('does not do any requests on error state', () => {
        props.sparkState.hasError = true;
        setup(props);

        expect(props.connectToMercury).not.toHaveBeenCalled();
        expect(props.updateWidgetStatus).not.toHaveBeenCalled();
        expect(props.getFeature).not.toHaveBeenCalled();
      });

      it('gets feature flags', () => {
        setup(props);

        expect(props.getFeature).toHaveBeenCalled();
      });

      it('does not get feature flags after initial fetch', () => {
        props.widgetStatus.hasFetchedGroupMessageNotificationFeature = true;
        props.widgetStatus.hasFetchedMentionNotificationFeature = true;

        setup(props);

        expect(props.getFeature).not.toHaveBeenCalled();
      });

      it('connects to websockets', () => {
        setup(props);

        expect(props.connectToMercury).toHaveBeenCalled();
      });
    });

    describe('after websocket connect', () => {
      beforeEach(() => {
        props.sparkState.authenticated = true;
        props.sparkState.registered = true;
        props.sparkInstance.internal.device.registered = true;

        props.mercuryStatus.connected = true;
      });

      it('should get initial spaces', () => {
        setup(props);

        expect(props.fetchSpaces).toHaveBeenCalled();
        const fetchConfig = props.fetchSpaces.mock.calls[0][1];

        // Only the initial calls have deferDecrypt. Otherwise it is the all call
        expect(fetchConfig.deferDecrypt).toBeDefined();
      });

      it('should not get initial spaces again during initial space load', () => {
        props.widgetStatus.isFetchingInitialSpaces = true;
        setup(props);

        expect(props.fetchSpaces).not.toHaveBeenCalled();
      });

      it('should not get initial spaces again after initial space load', () => {
        props.widgetStatus.hasFetchedInitialSpaces = true;
        setup(props);
        const fetchConfig = props.fetchSpaces.mock.calls[0][1];

        // Only the initial calls have deferDecrypt. Otherwise it is the all call
        expect(fetchConfig.deferDecrypt).not.toBeDefined();
      });

      it('should load the amount based on spaceLoadCount', () => {
        props.spaceLoadCount = 10;

        setup(props);
        const fetchConfig = props.fetchSpaces.mock.calls[0][1];

        expect(fetchConfig.limit).toBe(10);
      });
    });

    describe('after initial space fetch', () => {
      beforeEach(() => {
        // SDK Register
        props.sparkState.authenticated = true;
        props.sparkState.registered = true;
        props.sparkInstance.internal.device.registered = true;
        // Websocket
        props.mercuryStatus.connected = true;
        // Initial Fetch
        props.widgetStatus.isFetchingInitialSpaces = true;
        props.widgetStatus.hasFetchedInitialSpaces = true;
      });

      it('should get all spaces', () => {
        setup(props);

        expect(props.fetchSpaces).toHaveBeenCalled();
      });

      it('should not get all spaces again during all space load', () => {
        props.widgetStatus.isFetchingAllSpaces = true;
        setup(props);

        expect(props.fetchSpaces).not.toHaveBeenCalled();
      });

      it('should not get all spaces again after all space load', () => {
        props.widgetStatus.hasFetchedAllSpaces = true;
        setup(props);
        expect(props.fetchSpaces).not.toHaveBeenCalled();
      });
    });

    describe('after all space fetch', () => {
      beforeEach(() => {
        // SDK Register
        props.sparkState.authenticated = true;
        props.sparkState.registered = true;
        props.sparkInstance.internal.device.registered = true;
        // Websocket
        props.mercuryStatus.connected = true;
        // Initial Fetch
        props.widgetStatus.isFetchingInitialSpaces = true;
        props.widgetStatus.hasFetchedInitialSpaces = true;
        // All Space Fetch
        props.widgetStatus.isFetchingAllSpaces = true;
        props.widgetStatus.hasFetchedAllSpaces = true;
        props.spacesList = [
          {
            isDecrypting: false,
            participants: [
              {
                id: 'abc123'
              },
              {
                id: 'my-user-id'
              }
            ],
            type: 'direct'
          },
          {
            isDecrypting: false,
            participants: [
              {
                id: 'abc123'
              },
              {
                id: 'my-user-id'
              }
            ],
            type: 'group'
          },
          {
            isDecrypting: true,
            type: 'group'
          }
        ];
      });

      it('should get all avatars', () => {
        setup(props);

        expect(props.fetchAvatar).toHaveBeenCalled();
      });

      it('should not get all avatars again during all avatar load', () => {
        props.widgetStatus.isFetchingAvatars = true;
        setup(props);

        expect(props.fetchAvatar).not.toHaveBeenCalled();
      });

      it('should not get all avatars again after all avatar load', () => {
        props.widgetStatus.hasFetchedAvatars = true;
        setup(props);

        expect(props.fetchAvatar).not.toHaveBeenCalled();
      });

      describe('with extendedLoad disabled', () => {
        beforeEach(() => {
          props.extendedLoad = false;
        });

        it('should not get all spaces', () => {
          props.widgetStatus.hasFetchedInitialSpaces = true;
          setup(props);

          expect(props.fetchSpaces).not.toHaveBeenCalled();
        });
      });
    });
  });

  describe('#getSpaceAvatar', () => {
    it('should not fetch avatars for a decrypting space', () => {
      const space = {
        isDecrypting: true
      };

      getSpaceAvatar(space, props);

      expect(props.fetchAvatar).not.toHaveBeenCalled();
    });

    it('should fetch the avatar for the group space id', () => {
      const space = {
        id: 'my-group-id',
        isDecrypting: false,
        type: 'group'
      };

      getSpaceAvatar(space, props);
      const fetchConfig = props.fetchAvatar.mock.calls[0][0];

      expect(fetchConfig.space.id).toEqual('my-group-id');
    });

    it('should fetch the avatar for the to person id', () => {
      const space = {
        isDecrypting: false,
        participants: [
          'my-user-id',
          'to-user-id'
        ],
        type: 'direct'
      };

      getSpaceAvatar(space, props);
      const fetchConfig = props.fetchAvatar.mock.calls[0][0];

      expect(fetchConfig.userId).toEqual('to-user-id');
    });
  });
});
