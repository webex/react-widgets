import _ from 'lodash';

export const ACKNOWLEDGE_ACTIVITY = `conversation/ACKNOWLEDGE_ACTIVITY`;
export const ADD_ACTIVITIES_TO_CONVERSATION = `conversation/ADD_ACTIVITIES_TO_CONVERSATION`;
export const ADD_PARTICIPANT = `conversation/ADD_PARTICIPANT`;
export const CREATE_CONVERSATION_BEGIN = `conversation/CREATE_CONVERSATION_BEGIN`;
export const CREATE_CONVERSATION = `conversation/CREATE_CONVERSATION`;
export const UPDATE_CONVERSATION_STATE = `conversation/UPDATE_CONVERSATION_STATE`;
export const DELETE_ACTIVITY_FROM_CONVERSATION = `conversation/DELETE_ACTIVITY_FROM_CONVERSATION`;
export const RECEIVE_MERCURY_COMMENT = `conversation/RECEIVE_MERCURY_COMMENT`;
export const RECEIVE_MERCURY_ACTIVITY = `conversation/RECEIVE_MERCURY_ACTIVITY`;
export const REMOVE_PARTICIPANT = `conversation/REMOVE_PARTICIPANT`;

function acknowledgeActivity(activity) {
  return {
    type: ACKNOWLEDGE_ACTIVITY,
    payload: {
      activity
    }
  };
}

function addActivitiesToConversation(activities) {
  return {
    type: ADD_ACTIVITIES_TO_CONVERSATION,
    payload: {
      activities
    }
  };
}

function createConversationBegin() {
  return {
    type: CREATE_CONVERSATION_BEGIN
  };
}

function storeConversation(conversation) {
  return {
    type: CREATE_CONVERSATION,
    payload: {
      conversation
    }
  };
}

function deleteActivityFromConversation(conversation, activity) {
  return {
    type: DELETE_ACTIVITY_FROM_CONVERSATION,
    payload: {
      conversation,
      activity
    }
  };
}

/**
 * Adds a participant to conversation's participants array
 *
 * @export
 * @param {object} participant
 * @returns {object}
 */
export function addParticipant(participant) {
  return {
    type: ADD_PARTICIPANT,
    payload: {
      participant
    }
  };
}

export function receiveMercuryComment(activity) {
  return {
    type: RECEIVE_MERCURY_COMMENT,
    payload: {
      activity
    }
  };
}

export function receiveMercuryActivity(activity) {
  return {
    type: RECEIVE_MERCURY_ACTIVITY,
    payload: {
      activity
    }
  };
}

/**
 * Removes a participant from the participants array
 *
 * @export
 * @param {object} participant
 * @returns {object}
 */
export function removeParticipant(participant) {
  return {
    type: REMOVE_PARTICIPANT,
    payload: {
      participant
    }
  };
}

export function updateConversationState(conversationState) {
  return {
    type: UPDATE_CONVERSATION_STATE,
    payload: {
      conversationState
    }
  };
}

/**
 * Acknowledges (marks as read) an activity
 * @param {object} conversation (immutable object expected)
 * @param {object} activity
 * @param {object} spark
 * @returns {function}
 */
export function acknowledgeActivityOnServer(conversation, activity, spark) {
  return (dispatch) =>
    spark.internal.conversation.acknowledge(conversation.toJS(), activity).then(() => dispatch(acknowledgeActivity(activity)));
}

/**
 * Creates/Opens a conversation with a user
 *
 * @param {Array} participants List of userIds or emails
 * @param {object} spark
 * @returns {function}
 */
export function createConversation(participants = [], spark) {

  return (dispatch) => {
    dispatch(createConversationBegin());

    return spark.internal.conversation.create({
      participants
    }, {
      latestActivity: true,
      activitiesLimit: 40,
      participantAckFilter: `all`
    })
      .then((conversation) => dispatch(storeConversation(conversation)));
  };
}

/**
 * Deletes an activity from a conversation
 * @param {object} conversation (immutable object expected)
 * @param {object} activity
 * @param {object} spark
 * @returns {function}
 */
export function deleteActivity(conversation, activity, spark) {
  return (dispatch) =>
    spark.internal.conversation.delete(conversation.toJS(), activity)
      .then(() => dispatch(deleteActivityFromConversation(conversation, activity)));
}

/**
 * Retrieves a conversation with SpaceId
 *
 * @param {string} id SpaceId
 * @param {object} spark
 * @returns {Promise}
 */
export function getConversation(id, spark) {
  // check if id is uuid
  const uuidTest = new RegExp(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/);
  let uuid = id;
  let conversation;
  if (!uuidTest.test(uuid)) {
    uuid = atob(id).split(`/`).pop();
  }
  return (dispatch) => {
    dispatch(createConversationBegin());
    if (uuidTest.test(uuid)) {
      return spark.internal.conversation.get({
        id: uuid
      }, {
        latestActivity: true,
        activitiesLimit: 40,
        participantAckFilter: `all`,
        includeParticipants: true
      })
        .then((createdConversation) => {
          conversation = createdConversation;
          return dispatch(storeConversation(conversation));
        })
        .then(() => computeRoomProperties(dispatch, conversation, spark));
    }
    return false;
  };
}

/**
 * Fetches activities that were posted after sinceDate
 * @param {string} conversationId
 * @param {string} sinceDate
 * @param {object} spark
 * @returns {function}
 */
export function loadMissingActivities(conversationId, sinceDate, spark) {
  return (dispatch) => {
    dispatch(updateConversationState({isLoadingMissing: true}));
    return dispatch(fetchAndMergeMissingActivities(conversationId, sinceDate))
      .then(() => dispatch(updateConversationState({isLoadingMissing: false})));
  };

  function fetchAndMergeMissingActivities(fetchConversationId, fetchSinceDate) {
    return (dispatch) => {
      const limit = 50;
      return spark.internal.conversation.listActivities({
        lastActivityFirst: false,
        fetchConversationId,
        limit,
        fetchSinceDate
      })
      .then((activities) => {
        if (activities.length) {
          dispatch(addActivitiesToConversation(activities));
          if (activities.length === limit) {
            // We still have (possibly) more activities missing
            const lastActivityDate = _.last(activities).published;
            return fetchAndMergeMissingActivities(fetchConversationId, lastActivityDate, dispatch);
          }
        }
        return Promise.resolve();
      });
    };
  }
}

/**
 * Loads activities for a conversation previous to the maxDate
 *
 * @export
 * @param {string} conversationId
 * @param {string} maxDate
 * @param {object} spark
 * @returns {function}
 */
export function loadPreviousMessages(conversationId, maxDate, spark) {
  return (dispatch) => {
    dispatch(updateConversationState({isLoadingHistoryUp: true}));
    return spark.internal.conversation.listActivities({
      conversationId,
      lastActivityFirst: true,
      limit: 20,
      maxDate
    })
    .then((activities) => {
      dispatch(addActivitiesToConversation(activities));
      dispatch(updateConversationState({isLoadingHistoryUp: false}));
    });
  };
}

/**
 * Adds participant to the conversation on the server
 *
 * @export
 * @param {object} conversation (immutable object expected)
 * @param {object} participant the full participant object (js-sdk required)
 * @param {object} spark
 * @returns {function}
 */
export function addParticipantToConversation(conversation, participant, spark) {
  return (dispatch) => {
    dispatch(updateConversationState({addParticipantError: null, isAddingParticipant: true}));
    return spark.internal.conversation.add(conversation.toJS(), participant)
      .then(() =>
        // Add will come as mercury event
        dispatch(updateConversationState({addParticipantError: null, isAddingParticipant: false}))
      )
      .catch((error) =>
        dispatch(updateConversationState({addParticipantError: error, isAddingParticipant: false}))
      );
  };
}

/**
 * Computes and updates room properties
 * @param {Function} dispatch
 * @param {Object} conversation
 * @param {Object} spark
 * @returns {Promise}
 */
function computeRoomProperties(dispatch, conversation, spark) {
  const lockedTag = `LOCKED`;
  const oneOnOneTag = `ONE_ON_ONE`;
  const isLocked = conversation.tags.some((tag) => tag === lockedTag);
  const isOneOnOne = conversation.tags.some((tag) => tag === oneOnOneTag);
  const currentUserId = spark.internal.device.userId;
  const currentUserParticipant = conversation.participants.items.find((participant) => participant.id === currentUserId);
  const isModerator = currentUserParticipant && currentUserParticipant.roomProperties && currentUserParticipant.roomProperties.isModerator;
  return dispatch(updateConversationState({isLocked, isModerator, isOneOnOne}));
}
