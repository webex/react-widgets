import _ from 'lodash';
import {metrics} from '@ciscospark/react-component-utils';

export const ACKNOWLEDGE_ACTIVITY = `conversation/ACKNOWLEDGE_ACTIVITY`;
export const ADD_ACTIVITIES_TO_CONVERSATION = `conversation/ADD_ACTIVITIES_TO_CONVERSATION`;
export const CREATE_CONVERSATION_BEGIN = `conversation/CREATE_CONVERSATION_BEGIN`;
export const CREATE_CONVERSATION = `conversation/CREATE_CONVERSATION`;
export const UPDATE_CONVERSATION_STATE = `conversation/UPDATE_CONVERSATION_STATE`;
export const DELETE_ACTIVITY_FROM_CONVERSATION = `conversation/DELETE_ACTIVITY_FROM_CONVERSATION`;
export const RECEIVE_MERCURY_COMMENT = `conversation/RECEIVE_MERCURY_COMMENT`;
export const RECEIVE_MERCURY_ACTIVITY = `conversation/RECEIVE_MERCURY_ACTIVITY`;
export const UPDATE_MERCURY_STATE = `conversation/UPDATE_MERCURY_STATE`;

function acknowledgeActivity(activity) {
  return {
    type: ACKNOWLEDGE_ACTIVITY,
    payload: {
      activity
    }
  };
}

function addActivitiesToConversation(activities) {
  return {
    type: ADD_ACTIVITIES_TO_CONVERSATION,
    payload: {
      activities
    }
  };
}

function createConversationBegin() {
  return {
    type: CREATE_CONVERSATION_BEGIN
  };
}

function storeConversation(conversation) {
  return {
    type: CREATE_CONVERSATION,
    payload: {
      conversation
    }
  };
}

function deleteActivityFromConversation(conversation, activity) {
  return {
    type: DELETE_ACTIVITY_FROM_CONVERSATION,
    payload: {
      conversation,
      activity
    }
  };
}

export function receiveMercuryComment(activity) {
  return {
    type: RECEIVE_MERCURY_COMMENT,
    payload: {
      activity
    }
  };
}

export function receiveMercuryActivity(activity) {
  return {
    type: RECEIVE_MERCURY_ACTIVITY,
    payload: {
      activity
    }
  };
}

export function updateMercuryState(mercuryState) {
  return {
    type: UPDATE_MERCURY_STATE,
    payload: {
      mercuryState
    }
  };
}

function updateConversationState(conversationState) {
  return {
    type: UPDATE_CONVERSATION_STATE,
    payload: {
      conversationState
    }
  };
}

/**
 * Acknowledges (marks as read) an activity
 * @param {object} conversation (immutable object expected)
 * @param {object} activity
 * @param {object} spark
 * @returns {function}
 */
export function acknowledgeActivityOnServer(conversation, activity, spark) {
  return (dispatch) =>
    spark.conversation.acknowledge(conversation.toJS(), activity).then(() => dispatch(acknowledgeActivity(activity)));
}

/**
 * Creates/Opens a conversation with a user
 *
 * @param {Array} participants List of userIds or emails
 * @param {object} spark
 * @returns {function}
 */
export function createConversation(participants = [], spark) {

  const metricName = {
    CREATE_CONVO_START: `createConversation:start`,
    CREATE_CONVO_END: `createConversation:end`,
    CREATE_CONVO_DURATION: `createConversation:duration`
  };

  return (dispatch) => {
    metrics.saveElapsedTime(metricName.CREATE_CONVO_START);
    metrics.sendTempMetric(metricName.CREATE_CONVO_START, spark);

    dispatch(createConversationBegin());

    return spark.conversation.create({
      participants
    }, {
      latestActivity: true,
      activitiesLimit: 40,
      participantAckFilter: `all`
    })
      .then((conversation) => {
        metrics.saveElapsedTime(metricName.CREATE_CONVO_END);
        metrics.sendTempMetric(metricName.CREATE_CONVO_END, spark);
        metrics.sendDurationMetric(
          metricName.CREATE_CONVO_DURATION,
          metricName.CREATE_CONVO_START,
          metricName.CREATE_CONVO_END,
          spark
        );
        return dispatch(storeConversation(conversation));
      });
  };
}

/**
 * Deletes an activity from a conversation
 * @param {object} conversation (immutable object expected)
 * @param {object} activity
 * @param {object} spark
 * @returns {function}
 */
export function deleteActivity(conversation, activity, spark) {
  return (dispatch) =>
    spark.conversation.delete(conversation.toJS(), activity)
      .then(() => dispatch(deleteActivityFromConversation(conversation, activity)));
}

/**
 * Retrieves a conversation with SpaceId
 *
 * @param {string} id SpaceId
 * @param {object} spark
 * @returns {Promise}
 */
export function getConversation(id, spark) {
  // check if id is uuid
  const uuidTest = new RegExp(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/);
  let uuid = id;
  if (!uuidTest.test(uuid)) {
    uuid = atob(id).split(`/`).pop();
  }
  return (dispatch) => {
    dispatch(createConversationBegin());
    if (uuidTest.test(uuid)) {
      return spark.conversation.get({
        id: uuid
      }, {
        latestActivity: true,
        activitiesLimit: 40,
        participantAckFilter: `all`,
        includeParticipants: true
      })
        .then((conversation) => dispatch(storeConversation(conversation)));
    }
    return false;
  };
}

/**
 * Fetches activities that were posted after sinceDate
 * @param {string} conversationId
 * @param {string} sinceDate
 * @param {object} spark
 * @returns {function}
 */
export function loadMissingActivities(conversationId, sinceDate, spark) {
  return (dispatch) => {
    dispatch(updateConversationState({isLoadingMissing: true}));
    return fetchAndMergeMissingActivities(conversationId, sinceDate, dispatch)
      .then(() => dispatch(updateConversationState({isLoadingMissing: false})));
  };

  function fetchAndMergeMissingActivities(fetchConversationId, fetchSinceDate, dispatch) {
    const limit = 50;
    return spark.conversation.listActivities({
      lastActivityFirst: false,
      fetchConversationId,
      limit,
      fetchSinceDate
    })
    .then((activities) => {
      if (activities.length) {
        dispatch(addActivitiesToConversation(activities));
        if (activities.length === limit) {
          // We still have (possibly) more activities missing
          const lastActivityDate = _.last(activities).published;
          return fetchAndMergeMissingActivities(fetchConversationId, lastActivityDate, dispatch);
        }
      }
      return Promise.resolve();
    });
  }
}

/**
 * Loads activities for a conversation previous to the maxDate
 *
 * @export
 * @param {string} conversationId
 * @param {string} maxDate
 * @param {object} spark
 * @returns {function}
 */
export function loadPreviousMessages(conversationId, maxDate, spark) {
  return (dispatch) => {
    dispatch(updateConversationState({isLoadingHistoryUp: true}));
    return spark.conversation.listActivities({
      conversationId,
      lastActivityFirst: true,
      limit: 20,
      maxDate
    })
    .then((activities) => {
      dispatch(addActivitiesToConversation(activities));
      dispatch(updateConversationState({isLoadingHistoryUp: false}));
    });
  };
}
