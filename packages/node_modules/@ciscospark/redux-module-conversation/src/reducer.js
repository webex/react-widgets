/* eslint complexity: ["error", 12] */
import {fromJS, Map, OrderedMap} from 'immutable';
import {
  ACKNOWLEDGE_ACTIVITY,
  ADD_ACTIVITIES_TO_CONVERSATION,
  ADD_PARTICIPANT,
  ADD_PARTICIPANT_INFLIGHT,
  CREATE_CONVERSATION,
  CREATE_CONVERSATION_BEGIN,
  RECEIVE_MERCURY_ACTIVITY,
  RECEIVE_MERCURY_COMMENT,
  REMOVE_PARTICIPANT,
  REMOVE_PARTICIPANT_INFLIGHT,
  UPDATE_CONVERSATION_STATE
} from './actions';

export const initialState = fromJS({
  activities: new OrderedMap(),
  id: null,
  inFlightParticipants: {
    adding: new Map(),
    removing: new Map()
  },
  lastAcknowledgedActivityId: null,
  participants: [],
  status: {
    addParticipantError: null,
    isFetching: false,
    isListeningToMercury: false,
    isLoaded: false,
    isLoadingHistoryUp: false,
    isLoadingMissing: false,
    isLocked: true,
    isModerator: false,
    isOneOnOne: true,
    error: null,
    removeParticipantError: null
  }
});

export default function reducer(state = initialState, action) {
  switch (action.type) {
  case ACKNOWLEDGE_ACTIVITY: {
    return state.set(`lastAcknowledgedActivityId`, action.payload.activity.id);
  }
  case ADD_ACTIVITIES_TO_CONVERSATION: {
    const addedActivities = new OrderedMap(action.payload.activities.map((activity) => [activity.url, activity]));
    let activities = state.get(`activities`).mergeDeep(addedActivities);
    activities = activities.sortBy((activity) => activity.published);
    return state.set(`activities`, activities);
  }

  case ADD_PARTICIPANT: {
    const participants = state.get(`participants`).push(fromJS(action.payload.participant));
    return state
      .set(`participants`, participants)
      .removeIn([`inFlightParticipants`, `adding`, action.payload.participant.id]);
  }

  case ADD_PARTICIPANT_INFLIGHT: {
    const {participant} = action.payload;
    return state.setIn([`inFlightParticipants`, `adding`, participant.id], participant);
  }

  case CREATE_CONVERSATION_BEGIN: {
    return state.setIn([`status`, `isFetching`], true);
  }

  case CREATE_CONVERSATION: {
    const {
      defaultActivityEncryptionKeyUrl,
      avatar,
      displayName,
      id,
      kmsResourceObjectUrl,
      locusUrl,
      participants,
      tags,
      published,
      url,
      lastReadableActivityDate
    } = action.payload.conversation;

    const conversationActivities = action.payload.conversation.activities.items;

    let activities = new OrderedMap(conversationActivities.map((activity) => [activity.url, activity]));
    activities = activities.sortBy((activity) => activity.published);

    return state
      .set(`activities`, activities)
      .mergeDeep({
        avatar,
        displayName,
        defaultActivityEncryptionKeyUrl,
        id,
        kmsResourceObjectUrl,
        locusUrl,
        url,
        published,
        tags,
        lastReadableActivityDate,
        status: {
          isFetching: false,
          isLoaded: true
        },
        participants: participants.items
      });
  }

  case RECEIVE_MERCURY_ACTIVITY: {
    return receiveMercuryActivity(state, action);
  }

  case RECEIVE_MERCURY_COMMENT: {
    const receivedActivity = action.payload.activity;
    let activities = state.get(`activities`).set(receivedActivity.url, receivedActivity);
    activities = activities.sortBy((activity) => activity.published);
    return state.set(`activities`, activities);
  }

  case REMOVE_PARTICIPANT: {
    const participants = state.get(`participants`).takeWhile((p) => p.get(`id`) !== action.payload.participant.id);
    return state
      .set(`participants`, participants)
      .removeIn([`inFlightParticipants`, `removing`, action.payload.participant.id]);
  }

  case REMOVE_PARTICIPANT_INFLIGHT: {
    const {participant} = action.payload;
    return state.setIn([`inFlightParticipants`, `removing`, participant.id], participant);
  }

  case UPDATE_CONVERSATION_STATE: {
    return state.mergeIn([`status`], action.payload.conversationState);
  }

  default: {
    return state;
  }
  }
}

function receiveMercuryActivity(state, action) {
  let activities = state.get(`activities`);
  let participants = state.get(`participants`);
  const {activity} = action.payload;
  const {verb} = activity;
  if (verb === `delete`) {
    // Find activity that is being deleted and change it to a tombstone
    const deletedId = activity.object.id;
    activities = activities.map((activityItem) => {
      if (activityItem.id === deletedId) {
        return Object.assign({}, activityItem, {
          verb: `tombstone`
        });
      }
      return activityItem;
    });
  }
  else if (verb === `acknowledge`) {
    // acknowledge is a read receipt. we need to update the participants who
    // are listed in this acknowledgement
    const actorId = activity.actor.id;
    participants = state.get(`participants`).map((participant) => {
      if (participant.get(`id`) === actorId) {
        return participant
          .setIn([`roomProperties`, `lastSeenActivityUUID`], activity.object.id)
          .setIn([`roomProperties`, `lastSeenActivityDate`], activity.published);
      }
      return participant;
    });
  }
  return state.set(`activities`, activities).set(`participants`, participants);
}
