/* eslint complexity: ["error", 10] */
import {Map, OrderedMap} from 'immutable';
import {
  ACKNOWLEDGE_ACTIVITY,
  ADD_ACTIVITIES_TO_CONVERSATION,
  CREATE_CONVERSATION,
  CREATE_CONVERSATION_BEGIN,
  RECEIVE_MERCURY_ACTIVITY,
  RECEIVE_MERCURY_COMMENT,
  UPDATE_CONVERSATION_STATE,
  UPDATE_MERCURY_STATE
} from './actions';

export const initialState = new Map({
  activities: new OrderedMap(),
  id: null,
  lastAcknowledgedActivityId: null,
  isFetching: false,
  isLoaded: false,
  isLoadingHistoryUp: false,
  mercuryState: {
    isListening: false
  },
  participants: [],
  status: {
    error: null
  }
});

export default function reducer(state = initialState, action) {
  switch (action.type) {
  case ACKNOWLEDGE_ACTIVITY: {
    return state.set(`lastAcknowledgedActivityId`, action.payload.activity.id);
  }
  case ADD_ACTIVITIES_TO_CONVERSATION: {
    const addedActivities = new OrderedMap(action.payload.activities.map((activity) => [activity.url, activity]));
    let activities = state.get(`activities`).mergeDeep(addedActivities);
    activities = activities.sortBy((activity) => activity.published);
    return state.set(`activities`, activities);
  }

  case CREATE_CONVERSATION_BEGIN: {
    return state.set(`isFetching`, true);
  }

  case CREATE_CONVERSATION: {
    const {
      defaultActivityEncryptionKeyUrl,
      id,
      kmsResourceObjectUrl,
      locusUrl,
      participants,
      url
    } = action.payload.conversation;

    const conversationActivities = action.payload.conversation.activities.items;

    let activities = new OrderedMap(conversationActivities.map((activity) => [activity.url, activity]));
    activities = activities.sortBy((activity) => activity.published);

    return state
      .set(`activities`, activities)
      .merge({
        defaultActivityEncryptionKeyUrl,
        id,
        kmsResourceObjectUrl,
        locusUrl,
        url,
        isFetching: false,
        isLoaded: true,
        participants: participants.items
      });
  }

  case RECEIVE_MERCURY_ACTIVITY: {
    return receiveMercuryActivity(state, action);
  }

  case RECEIVE_MERCURY_COMMENT: {
    const receivedActivity = action.payload.activity;
    let activities = state.get(`activities`).set(receivedActivity.url, receivedActivity);
    activities = activities.sortBy((activity) => activity.published);
    return state.set(`activities`, activities);
  }

  case UPDATE_CONVERSATION_STATE: {
    return state.merge(action.payload.conversationState);
  }

  case UPDATE_MERCURY_STATE: {
    return state.set(`mercuryState`, action.payload.mercuryState);
  }

  default: {
    return state;
  }
  }
}

function receiveMercuryActivity(state, action) {
  let activities = state.get(`activities`);
  let participants = state.get(`participants`);
  const {activity} = action.payload;
  const {verb} = activity;
  if (verb === `delete`) {
    // Find activity that is being deleted and change it to a tombstone
    const deletedId = activity.object.id;
    activities = activities.map((activityItem) => {
      if (activityItem.id === deletedId) {
        return Object.assign({}, activityItem, {
          verb: `tombstone`
        });
      }
      return activityItem;
    });
  }
  else if (verb === `acknowledge`) {
    // acknowledge is a read receipt. we need to update the participants who
    // are listed in this acknowledgement
    const actorId = activity.actor.id;
    participants = state.get(`participants`).map((participant) => {
      if (participant.id === actorId) {
        return Object.assign({}, participant, {
          roomProperties: Object.assign({}, participant.roomProperties, {
            lastSeenActivityUUID: activity.object.id,
            lastSeenActivityDate: activity.published
          })
        });
      }
      return participant;
    });
  }
  return state.set(`activities`, activities).set(`participants`, participants);
}
