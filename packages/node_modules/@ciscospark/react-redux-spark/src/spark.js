import '@webex/plugin-logger';
import '@webex/plugin-authorization';
import '@webex/internal-plugin-mercury';
import '@webex/plugin-people';
import '@webex/internal-plugin-conversation';
import '@webex/plugin-phone';
import '@webex/plugin-rooms';
import '@webex/internal-plugin-flag';
import '@webex/internal-plugin-feature';
import '@webex/internal-plugin-presence';
import '@webex/internal-plugin-search';
import '@webex/internal-plugin-team';
import Spark from '@webex/webex-core';
import LocalForageStoreAdapter from '@webex/storage-adapter-local-forage';

/**
 * Evaluates the federation environment variable so that
 * it can be used to configure federation.
 * @returns {boolean} whether to configure federation
 */
function configureFederation() {
  const fed = process.env.FEDERATION;

  if (fed && (fed === '0' || fed.toLowerCase() === 'false')) {
    return false;
  }

  // Federation is on by default.
  return true;
}

/**
 * Creates the default spark config for the widgets
 * @param {Object} [options={}]
 * @returns {Object}
 */
function defaultConfig(options = {}) {
  return {
    appName: 'spark-widgets',
    appVersion: process.env.REACT_CISCOSPARK_VERSION,
    device: {
      ephemeral: true
    },
    logger: {
      level: options.logLevel || process.env.NODE_ENV === 'production' ? 'silent' : 'trace'
    },
    conversation: {
      allowedInboundTags: {
        'spark-mention': ['data-object-type', 'data-object-id', 'data-object-url'],
        a: ['href'],
        b: [],
        blockquote: ['class'],
        strong: [],
        i: [],
        em: [],
        pre: [],
        code: [],
        br: [],
        hr: [],
        p: [],
        ul: [],
        ol: [],
        li: [],
        h1: [],
        h2: [],
        h3: []
      },
      allowedOutboundTags: {
        'spark-mention': ['data-object-type', 'data-object-id', 'data-object-url'],
        a: ['href'],
        b: [],
        blockquote: ['class'],
        strong: [],
        i: [],
        em: [],
        pre: [],
        code: [],
        br: [],
        hr: [],
        p: [],
        ul: [],
        ol: [],
        li: [],
        h1: [],
        h2: [],
        h3: []
      }
    },
    credentials: {
      client_id: process.env.CISCOSPARK_CLIENT_ID,
      federation: configureFederation(),
      scope: 'spark:all spark:kms'
    },
    // Added to help load blocking during decryption
    encryption: {
      kmsInitialTimeout: 10000
    },
    phone: {
      enableExperimentalGroupCallingSupport: true
    },
    storage: {
      unboundedAdapter: new LocalForageStoreAdapter('ciscospark-widgets')
    }
  };
}


/**
 * Creates a spark instance with the access token
 * @param {string} accessToken
 * @param {object} options
 * @returns {Promise<object>}
 */
function createSpark(accessToken, options = {}) {
  // Check if we already have a spark instance in memory
  let {ciscosparkInstance} = window;

  if (typeof ciscosparkInstance !== 'object') {
    const credentials = JSON.parse(localStorage.getItem('credentials') || false);

    ciscosparkInstance = new Spark({
      credentials: {
        authorization: {
          access_token: accessToken || credentials.access_token
        }
      },
      config: defaultConfig(options)
    });
    window.ciscosparkInstance = ciscosparkInstance;
  }

  return Promise.resolve(ciscosparkInstance);
}

/**
 * Creates a spark instance with the jwt token generated
 * by a guest issuer.
 * https://developer.ciscospark.com/guest-issuer.html
 *
 * @param {string} jwt
 * @param {object} options
 * @returns {Promise<object>}
 */
export function createSparkJwt(jwt, options = {}) {
  // Check if we already have a spark instance in memory
  let {ciscosparkInstance} = window;

  if (typeof ciscosparkInstance === 'object') {
    return Promise.resolve(ciscosparkInstance);
  }

  ciscosparkInstance = new Spark({
    config: defaultConfig(options)
  });
  window.ciscosparkInstance = ciscosparkInstance;

  return ciscosparkInstance.authorization.requestAccessTokenFromJwt({jwt}).then(() => ciscosparkInstance);
}

export default createSpark;
