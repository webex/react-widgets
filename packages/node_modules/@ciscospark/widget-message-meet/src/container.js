import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import {intlShape} from 'react-intl';
import classNames from 'classnames';
import autobind from 'autobind-decorator';

import {events as metricEvents} from '@ciscospark/react-redux-spark-metrics';
import {fetchCurrentUser, fetchToUser} from '@ciscospark/redux-module-user';
import {
  hangupCall,
  listenForIncomingCalls
} from '@ciscospark/redux-module-media';
import TitleBar from '@ciscospark/react-component-title-bar';
import Notifications from '@ciscospark/react-container-notifications';
import ActivityMenu from './components/activity-menu';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import ConnectedMessageComponent from '@ciscospark/widget-message';
import ConnectedMeetComponent from '@ciscospark/widget-meet';
import Button from '@ciscospark/react-component-button';
import Timer from '@ciscospark/react-component-timer';
import {ICON_TYPE_WAFFLE} from '@ciscospark/react-component-icon';
import {connectToMercury} from '@ciscospark/redux-module-mercury';

import {
  removeWidget,
  setActivityMenuVisible,
  toggleActivityMenu,
  setActivityMeet,
  setActivityMessage,
  ACTIVITY_TYPE_MEET,
  ACTIVITY_TYPE_MESSAGE
} from './actions';
import styles from './styles.css';
import messages from './messages';
import eventNames from './event-names';


export const INITIAL_ACTIVITY_TYPE_MEET = `meet`;
export const INITIAL_ACTIVITY_TYPE_MESSAGE = `message`;
export const INITIAL_ACTIVITY_TYPE_MENU = `activity-menu`;

/**
 * MessageMeetWidget Component
 */
export class MessageMeetWidget extends Component {

  componentWillMount() {
    const {
      sparkInstance,
      sparkState,
      startCall
    } = this.props;
    if (this.props.initialActivity === INITIAL_ACTIVITY_TYPE_MEET || startCall === true || startCall === `true`) {
      this.props.setActivityMeet();
    }
    if (this.props.initialActivity === INITIAL_ACTIVITY_TYPE_MENU) {
      this.props.setActivityMenuVisible(true);
    }

    if (sparkInstance && sparkState.authenticated) {
      this.fetchUsers(this.props);
    }
  }

  componentWillReceiveProps(nextProps) { // eslint-disable-line complexity
    const {
      conversation,
      media,
      metrics,
      sparkInstance,
      sparkState,
      mercury,
      widgetMessageMeet
    } = nextProps;

    const {
      authenticated,
      registered
    } = sparkState;

    const connected = mercury.getIn([`status`, `connected`]);
    const call = media.getIn([`calls`, conversation.get(`locusUrl`)]);
    const prevCall = this.props.media.getIn([`calls`, conversation.get(`locusUrl`)]);
    if (sparkInstance && authenticated) {
      this.fetchUsers(nextProps);
      if (!mercury.getIn([`status`, `hasConnected`]) && sparkInstance.internal.device.registered) {
        nextProps.connectToMercury(sparkInstance);
      }
      if (registered && connected) {
        if (!media.getIn([`status`, `isListening`]) && conversation.get(`locusUrl`)) {
          nextProps.listenForIncomingCalls(sparkInstance, conversation.get(`locusUrl`));
        }

        // When receivng an incoming call, switch to meet
        if (call && call.get(`instance`) && widgetMessageMeet.get(`activityType`) !== ACTIVITY_TYPE_MEET) {
          this.handleActivityMeet();
        }
      }
      if (metrics && conversation.get(`id`)) {
        metrics.sendEndMetric(metricEvents.WIDGET_LOAD);
      }
    }

    // Reset back to message view after call ends
    if (prevCall && prevCall.getIn([`callState`, `connected`])
      && (!call || !call.getIn([`callState`, `connected`]))) {
      this.handleActivityMessage();
    }
  }

  shouldComponentUpdate(nextProps) {
    const props = this.props;

    return nextProps.mercury.getIn([`status`, `connected`]) !== props.mercury.getIn([`status`, `connected`])
      || nextProps.media.get(`callStartTime`) !== props.media.get(`callStartTime`)
      || nextProps.user !== props.user
      || nextProps.conversation !== props.conversation
      || nextProps.avatar !== props.avatar
      || nextProps.indicators !== props.indicators
      || nextProps.widgetMessageMeet !== props.widgetMessageMeet;
  }

  componentWillUnmount() {
    // Hang up active call (if there is one)
    const isConnected = this.props.media.getIn([`status`, `isConnected`]);
    const isDialing = this.props.media.getIn([`status`, `isDialing`]);
    if (isDialing || isConnected) {
      this.props.hangupCall(this.props.media.get(`call`));
    }

    this.props.removeWidget();
  }

  fetchUsers(props) {
    const {
      sparkInstance,
      sparkState,
      toPersonEmail,
      toPersonId,
      user
    } = props;

    if (sparkState.registered && !user.get(`currentUser`) && !user.getIn([`status`, `isFetchingCurrentUser`])) {
      props.fetchCurrentUser(sparkInstance);
    }
    if (toPersonId || toPersonEmail && !user.get(`toUser`) && !user.getIn([`status`, `isFetchingToUser`])) {
      props.fetchToUser({toPersonEmail, toPersonId}, sparkInstance);
    }
  }

  @autobind
  handleActivityMeet() {
    const props = this.props;
    props.setActivityMeet();
    props.setActivityMenuVisible(false);
  }

  @autobind
  handleActivityMessage() {
    const props = this.props;
    props.setActivityMessage();
    props.setActivityMenuVisible(false);
  }

  @autobind
  handleMenuClick() {
    const props = this.props;
    props.toggleActivityMenu();
  }

  @autobind
  handleEvent(name, data) {
    const {onEvent} = this.props;
    if (typeof onEvent === `function`) {
      this.props.onEvent(name, data);
    }
  }

  /**
   * Render
   *
   * @returns {Object}
   */
  render() {
    const props = this.props;
    const {
      avatar,
      conversation,
      media,
      sparkInstance,
      spaceId,
      toPersonEmail,
      toPersonId,
      user,
      widgetMessageMeet
    } = props;
    const {formatMessage} = this.props.intl;

    const toUser = user.get(`toUser`);
    const activityMenuVisible = widgetMessageMeet.get(`activityMenuVisible`);
    const showMessage = widgetMessageMeet.get(`activityType`) === ACTIVITY_TYPE_MESSAGE;
    const showMeet = widgetMessageMeet.get(`activityType`) === ACTIVITY_TYPE_MEET;
    // Don't remove message component from DOM, just hide its display
    const messageComponentClassNames = showMessage ? `` : styles.hiddenComponent;
    const meetComponentClassNames = showMeet ? `` : styles.hiddenComponent;

    const callStartTime = media.get(`callStartTime`);
    // Don't load widgets until we have spark loaded and info on the toUser
    if (sparkInstance && conversation) {
      let toPersonName, toUserAvatarUrl;
      if (toUser) {
        toUserAvatarUrl = toUser && toUser.id && avatar.getIn([`items`, toUser.id]);
        toPersonName = toUser && toUser.displayName || toPersonEmail;
      }
      return (
        <div className={classNames(`ciscospark-widget-message-meet`, styles.widgetMessageMeet)}>
          <div className={classNames(`ciscospark-banner`, styles.banner)} />
          <div className={classNames(`ciscospark-widget-message-meet-inner`, styles.widgetMessageMeetInner)}>
            {
              activityMenuVisible &&
              <div className={classNames(`ciscospark-activity-menu-wrapper`, styles.activityMenuWrapper)}>
                <ActivityMenu
                  onExit={this.handleMenuClick}
                  onMeet={this.handleActivityMeet}
                  onMessage={this.handleActivityMessage}
                />
              </div>
            }
            <div className={classNames(`ciscospark-activity-menu-button-wrapper`, styles.activityMenuButtonWrapper)}>
              <div className={classNames(`ciscospark-activity-menu-button`, styles.activityMenuButton)}>
                <Button accessibilityLabel={`Main Menu`} iconType={ICON_TYPE_WAFFLE} onClick={this.handleMenuClick} />
              </div>
            </div>
            <div className={classNames(`ciscospark-title-bar-wrapper`, styles.titleBarWrapper)}>
              <TitleBar
                hasMenu
                image={toUserAvatarUrl}
                name={toPersonName}
              >
                {
                  callStartTime &&
                  <div className={classNames(`ciscospark-title-bar-call-timer`, styles.callTimer)}>
                    <Timer startTime={callStartTime} />
                  </div>
                }
              </TitleBar>
            </div>
            {
              (toPersonEmail || toPersonId) &&
              <div className={classNames(`ciscospark-meet-component-wrapper`, styles.activityComponentWrapper, meetComponentClassNames)}>
                <ConnectedMeetComponent
                  eventNames={eventNames}
                  injectProvider={false}
                  onEvent={this.handleEvent}
                  shouldStartMeeting={props.startCall}
                  sparkInstance={sparkInstance}
                  toPersonAvatar={toUserAvatarUrl}
                  toPersonEmail={toPersonEmail}
                  toPersonId={toPersonId}
                  toPersonName={toPersonName}
                  user={user}
                />
              </div>
            }
            <div className={classNames(`ciscospark-message-component-wrapper`, styles.activityComponentWrapper, messageComponentClassNames)}>
              <ConnectedMessageComponent
                eventNames={eventNames}
                injectProvider={false}
                onEvent={this.handleEvent}
                spaceId={spaceId}
                sparkInstance={sparkInstance}
                toPersonEmail={toPersonEmail}
                toPersonId={toPersonId}
                user={user}
              />
            </div>
            <Notifications />
          </div>
        </div>
      );
    }
    // Show loading screen until spark is ready
    return <LoadingScreen loadingMessage={formatMessage(messages.loadingMessage)} />;
  }
}

const injectedPropTypes = {
  conversation: PropTypes.object.isRequired,
  fetchCurrentUser: PropTypes.func.isRequired,
  fetchToUser: PropTypes.func.isRequired,
  hangupCall: PropTypes.func.isRequired,
  intl: intlShape.isRequired,
  listenForIncomingCalls: PropTypes.func.isRequired,
  media: PropTypes.object.isRequired,
  setActivityMenuVisible: PropTypes.func.isRequired,
  sparkInstance: PropTypes.object,
  sparkState: PropTypes.object.isRequired,
  toggleActivityMenu: PropTypes.func.isRequired,
  user: PropTypes.object.isRequired
};

export const ownPropTypes = {
  initialActivity: PropTypes.string,
  onEvent: PropTypes.func,
  spaceId: PropTypes.string,
  startCall: PropTypes.bool,
  toPersonEmail: PropTypes.string,
  toPersonId: PropTypes.string
};

MessageMeetWidget.propTypes = {
  ...ownPropTypes,
  ...injectedPropTypes
};

function mapStateToProps(state) {
  return {
    avatar: state.avatar,
    conversation: state.conversation,
    media: state.media,
    mercury: state.mercury,
    sparkInstance: state.spark.get(`spark`),
    sparkState: state.spark.get(`status`).toJS(),
    user: state.user,
    indicators: state.indicators,
    widgetMessageMeet: state.widgetMessageMeet
  };
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    connectToMercury,
    fetchCurrentUser,
    fetchToUser,
    hangupCall,
    listenForIncomingCalls,
    removeWidget,
    setActivityMeet,
    setActivityMessage,
    setActivityMenuVisible,
    toggleActivityMenu
  }, dispatch)
)(MessageMeetWidget);
