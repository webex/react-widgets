import React, {Component} from 'react';
import PropTypes from 'prop-types';
import {connect} from 'react-redux';
import {bindActionCreators} from 'redux';
import Dropzone from 'react-dropzone';
import classNames from 'classnames';
import _ from 'lodash';
import autobind from 'autobind-decorator';

import {
  constructFiles
} from '@ciscospark/react-component-utils';
import {fetchAvatarsForUsers} from '@ciscospark/redux-module-avatar';
import {
  acknowledgeActivityOnServer,
  createConversation,
  getConversation,
  loadMissingActivities,
  loadPreviousMessages,
  receiveMercuryActivity,
  receiveMercuryComment,
  updateMercuryState
} from '@ciscospark/redux-module-conversation';
import {
  fetchFlags,
  flagActivity,
  removeFlagFromServer
} from '@ciscospark/redux-module-flags';
import {
  setTyping
} from '@ciscospark/redux-module-indicators';
import {addFiles, removeInflightActivity, retryFailedActivity} from '@ciscospark/redux-module-activity';
import ConfirmationModal from '@ciscospark/react-component-confirmation-modal';
import Cover from '@ciscospark/react-component-cover';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import ScrollToBottomButton from '@ciscospark/react-component-scroll-to-bottom-button';
import ActivityList from '@ciscospark/react-container-activity-list';
import MessageComposer from '@ciscospark/react-container-message-composer';
import ReadReceipts from '@ciscospark/react-container-read-receipts';
import ScrollingActivity from '@ciscospark/react-container-scrolling-activity';

import {
  NOTIFICATION_TYPE_POST,
  createNotification
} from '@ciscospark/react-container-notifications';

import {
  confirmDeleteActivity,
  deleteActivityAndDismiss,
  hideDeleteModal,
  setScrollPosition,
  showScrollToBottomButton,
  updateHasNewMessage
} from './actions';

import styles from './styles.css';
import messages from './messages';

import {getMessageWidgetProps} from './selector';
import {
  eventNames as defaultEventNames,
  constructMessagesEventData,
  constructRoomsEventData
} from './events';

/**
 * MessageWidget Container
 * @extends Component
 */
export class MessageWidget extends Component {

  constructor(props) {
    super(props);
    this.handleScroll = _.debounce(this.handleScroll, 150);
  }

  componentDidMount() {
    this.eventNames = Object.assign({}, defaultEventNames, this.props.eventNames);
    // If our widget is instantiated with all the props loaded,
    // we can setup the conversation
    this.establishConversation(this.props);
  }

  componentWillReceiveProps(nextProps) {
    // This needs to fire here because props are loaded async via redux
    this.establishConversation(nextProps);
  }

  shouldComponentUpdate(nextProps) {
    const props = this.props;

    return nextProps.conversation !== props.conversation
      || nextProps.flags !== props.flags
      || nextProps.indicators !== props.indicators
      || nextProps.share !== props.share
      || nextProps.user !== props.user
      || nextProps.widgetMessage !== props.widgetMessage
      || nextProps.activity !== props.activity;
  }

  componentWillUpdate(nextProps) {
    const props = this.props;
    if (this.activityList
      && nextProps.conversation.get(`activities`).count() !== props.conversation.get(`activities`).count()) {
      this.scrollHeight = this.activityList.getScrollHeight();
    }
  }

  componentDidUpdate(prevProps) {
    const props = this.props;
    const activityList = this.activityList;
    if (activityList) {
      const activities = props.conversation.get(`activities`);
      const prevActivities = prevProps.conversation.get(`activities`);
      const lastActivityFromPrev = prevActivities.last();
      const lastActivityFromThis = activities.last();
      const objectType = lastActivityFromThis.object ? lastActivityFromThis.object.objectType : undefined;

      // If new activity comes in
      if (lastActivityFromPrev
        && lastActivityFromThis
        && activities.size !== prevActivities.size
        && lastActivityFromPrev.id !== lastActivityFromThis.id
        && props.user.get(`currentUser`).id !== lastActivityFromThis.actor.id
        && objectType !== `locusSessionSummary`
        ) {
        // Send notification of new message
        props.createNotification(lastActivityFromThis.url, NOTIFICATION_TYPE_POST);
      }
      this.updateScroll(activities, prevActivities, prevProps.widgetMessage.get(`scrollPosition`).scrollTop);
      if (this.shouldScrollToBottom(props, prevProps)) {
        activityList.scrollToBottom();
      }
    }
  }

  /**
   * Check if activity list should scroll to bottom
   *
   * @param {object} props
   * @param {object} prevProps
   * @returns {boolean}
   */
  shouldScrollToBottom(props, prevProps) {
    let shouldScrollToBottom = false;
    const activityList = this.activityList;
    const lastActivityFromPrev = prevProps.conversation.get(`activities`).last();
    const lastActivityFromThis = props.conversation.get(`activities`).last();
    // If new activity comes in
    if (lastActivityFromPrev && lastActivityFromThis && props.conversation.get(`activities`).count() !== prevProps.conversation.get(`activities`).count() && lastActivityFromPrev.id !== lastActivityFromThis.id) {
      // Scroll if from ourselves
      if (props.user.get(`currentUser`).id === lastActivityFromThis.actor.id) {
        shouldScrollToBottom = true;
      }
      else if (activityList.isScrolledToBottom()) {
        shouldScrollToBottom = true;
      }
    }
    else if (prevProps.conversation.get(`activities`).count() === 0) {
      shouldScrollToBottom = true;
    }
    // Scroll to show in flight activities
    if (props.activity.get(`inFlightActivities`).size && props.activity.get(`inFlightActivities`).size !== prevProps.activity.get(`inFlightActivities`).size) {
      shouldScrollToBottom = true;
    }

    return shouldScrollToBottom;
  }

  /**
   * Update scroll position when activity list changes
   * @param {object} activities
   * @param {object} prevActivities
   * @param {number} prevScrollTop
   * @returns {null}
   */
  updateScroll(activities, prevActivities, prevScrollTop) {
    const firstActivityFromPrev = prevActivities.first();
    const firstActivityFromThis = activities.first();
    const activityList = this.activityList;

    if (firstActivityFromThis && firstActivityFromPrev && firstActivityFromThis.id !== firstActivityFromPrev.id) {
      activityList.setScrollTop(activityList.getScrollHeight() - this.scrollHeight + prevScrollTop);
    }
  }


  /**
   * Attempts to fetch and establish a conversation
   *
   * @param {object} props
   *
   * @memberOf MessageWidget
   *
   * @returns {null}
   */
  establishConversation(props) { // eslint-disable-line complexity
    const {
      toPersonEmail,
      toPersonId,
      spaceId,
      sparkInstance,
      sparkState,
      conversation
    } = props;

    const {
      authenticated,
      registered
    } = sparkState;

    // Check if Spark instance and connections have been established
    if (sparkInstance && authenticated) {
      // Check if conversation has been retrieved
      if (registered && !conversation.get(`id`) && !conversation.getIn([`status`, `isFetching`])) {
        if (toPersonId || toPersonEmail) {
          props.createConversation([toPersonId || toPersonEmail], sparkInstance);
        }
        else if (spaceId) {
          props.getConversation(spaceId, sparkInstance);
        }
      }
    }
    // Setup once we have a conversation
    if (conversation.get(`id`)) {
      this.setupConversationActions(conversation, props);
    }
  }

  /**
   * Once a conversation has been established, setup
   * actions need to happen for app state
   *
   * @param {any} conversation
   * @param {any} nextProps
   *
   * @returns {null}
   */
  setupConversationActions(conversation, nextProps) {
    const {flags, sparkInstance, space} = nextProps;
    const {props} = this;
    const prevConversation = props.conversation;
    const id = conversation.get(`id`);
    if (!conversation.getIn([`status`, `isListeningToActivity`])) {
      this.listenToNewActivity(space, sparkInstance);
    }
    if (!conversation.getIn([`status`, `isListeningToTyping`])) {
      this.listenToTypingEvents(id, sparkInstance);
    }
    if (!flags.hasFetched && !flags.isFetching) {
      nextProps.fetchFlags(sparkInstance);
    }
    // We only want to fetch avatars when a new activity is seen
    const activityCount = conversation.get(`activities`).count();
    const prevActivities = prevConversation.get(`activities`);
    if (activityCount && activityCount !== prevActivities.count()) {
      this.getAvatarsFromConversation(conversation);
    }

    this.listenToBufferState(id, sparkInstance);
  }

  /**
   * Setup listeners for typing events
   *
   * @param {String} conversationId
   * @param {Object} sparkInstance
   * @returns {undefined}
   */
  listenToTypingEvents(conversationId, sparkInstance) {
    const {props} = this;
    props.updateMercuryState({isListeningToTyping: true});
    sparkInstance.internal.mercury.on(`event:status.start_typing`, (event) => {
      if (event.data.conversationId === conversationId) {
        props.setTyping(event.data.actor.id, true);
      }
    });

    sparkInstance.internal.mercury.on(`event:status.stop_typing`, (event) => {
      if (event.data.conversationId === conversationId) {
        props.setTyping(event.data.actor.id, false);
      }
    });
  }

  /**
   * Setup listeners for new activities
   *
   * @param {String} space
   * @param {Object} sparkInstance
   * @returns {undefined}
   */
  listenToNewActivity(space, sparkInstance) {
    const {props} = this;
    const handleEvent = this.handleEvent;
    const toUser = space.toPerson;
    props.updateMercuryState({isListeningToActivity: true});
    sparkInstance.internal.mercury.on(`event:conversation.activity`, (event) => {
      const activity = event.data.activity;
      const isSelf = activity.actor.id === props.user.get(`currentUser`).id;
      // Ignore activity from other conversations
      if (activity.target && activity.target.id === space.id) {
        if (activity.object.objectType === `activity`) {
          props.receiveMercuryActivity(activity);
          if (isSelf && activity.verb === `acknowledge`) {
            this.handleEvent(this.eventNames.SPACES_READ, constructRoomsEventData(space, activity));
          }
        }
        else {
          props.receiveMercuryComment(activity);
          props.removeInflightActivity(activity.clientTempId);
          // Emit message:created event
          // Do not emit unread if current user created the message
          if (!isSelf) {
            props.updateHasNewMessage(true);
            handleEvent(this.eventNames.SPACES_UNREAD, constructRoomsEventData(space, activity));
          }
          handleEvent(this.eventNames.MESSAGES_CREATED, constructMessagesEventData(activity, toUser));
        }
      }
    });
  }

  /**
   * Listens for mercury buffer state events and
   * fires off actions based on them
   * @param {string} conversationId
   * @param {object} sparkInstance
   */
  @autobind
  listenToBufferState(conversationId, sparkInstance) {
    sparkInstance.internal.mercury.on(`event:mercury.buffer_state`, (event) => {
      const {props} = this;
      const {
        conversation
      } = props;
      if (_.has(event, `data.bufferState.conversation`) && event.data.bufferState.conversation === `UNKNOWN`) {
        // Mercury does not contain enough information about the conversation, refetch
        const lastActivity = conversation.get(`activities`).last();
        const sinceDate = lastActivity.published || null;
        props.loadMissingActivities(conversationId, sinceDate, sparkInstance);
      }
    });
  }

  /**
   * Scroll activityList to bottom
   *
   * @returns {undefined}
   */
  @autobind
  handleScrollToBottom() {
    this.activityList.scrollToBottom();
  }

  /**
   * Additional actions after submitting a message
   *
   * @returns {undefined}
   */
  @autobind
  handleMessageSubmit() {
    this.activityList.scrollToBottom();
  }

  /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undfined}
   */
  @autobind
  handleEvent(name, data) {
    const {onEvent} = this.props;
    if (typeof onEvent === `function`) {
      this.props.onEvent(name, data);
    }
  }

  /**
   * Processes the activities and fetches avatars for users
   * that have not been fetched yet
   *
   * @param {Object} conversation
   *
   * @returns {null}
   */
  @autobind
  getAvatarsFromConversation(conversation) {
    const {props} = this;
    const {
      sparkInstance
    } = props;
    const activities = conversation.get(`activities`);
    const userIds = [];
    activities
      .forEach((activity) => {
        const userId = activity.actor.id;
        if (userIds.indexOf(userId) === -1) {
          userIds.push(userId);
        }
      });
    props.fetchAvatarsForUsers(userIds, sparkInstance);
  }

  /**
   * Store activity list from child component
   *
   * @param {Object} ref
   * @returns {undefined}
   */
  @autobind
  getActivityList(ref) {
    this.activityList = ref;
  }

  /**
   * Flag or unflag activity by Id
   *
   * @param {String} activityId
   * @returns {undefined}
   */
  @autobind
  handleActivityFlag(activityId) {
    const props = this.props;
    const {
      conversation,
      flags,
      sparkInstance
    } = props;
    const activity = conversation.get(`activities`).find((act) => act.id === activityId);
    if (activity) {
      const foundFlag = flags.flags.find((flag) => flag.activityUrl === activity.url);
      if (foundFlag) {
        props.removeFlagFromServer(foundFlag, sparkInstance);
      }
      else {
        props.flagActivity(activity, sparkInstance);
      }

    }
  }

  /**
   * Displays modal confirming activity delete
   *
   * @param {String} activityId
   * @returns {undefined}
   */
  @autobind
  handleActivityDelete(activityId) {
    const props = this.props;
    props.confirmDeleteActivity(activityId);
  }

  /**
   * Does the actual deletion of the activity after confirmation modal
   *
   * @returns {undefined}
   */
  @autobind
  handleConfirmActivityDelete() {
    const {props} = this;
    const {
      conversation,
      sparkInstance,
      widgetMessage
    } = props;

    const activityId = widgetMessage.get(`deletingActivityId`);

    const activity = conversation.get(`activities`).find((act) => act.id === activityId);
    if (activity) {
      props.deleteActivityAndDismiss(conversation, activity, sparkInstance);
    }
    else {
      props.hideDeleteModal();
    }
  }


  /**
   * Dismisses the confirmation modal
   *
   * @returns {undefined}
   */
  @autobind
  handleCancelActivityDelete() {
    const props = this.props;
    props.hideDeleteModal();
  }

  @autobind
  handleActivityRetry(activityId) {
    const props = this.props;
    const {
      activity,
      sparkInstance
    } = this.props;
    const failedActivity = activity.getIn([`activityFailures`, activityId]);
    return props.retryFailedActivity(failedActivity, sparkInstance);
  }

  /**
   * Adds dropped file into activity store
   *
   * @param {array} acceptedFiles
   * @returns {undefined}
   */
  @autobind
  handleFileDrop(acceptedFiles) {
    const props = this.props;
    const {
      activity,
      conversation,
      sparkInstance
    } = props;
    const files = constructFiles(acceptedFiles);
    props.addFiles(conversation, activity, files, sparkInstance);
  }

  /**
   * Perform actions when activity list scrolls
   *
   * @returns {undefined}
   */
  @autobind
  handleScroll() {
    const props = this.props;
    const activityList = this.activityList;
    const {
      conversation,
      sparkInstance,
      widgetMessage
    } = props;

    props.setScrollPosition({scrollTop: activityList.getScrollTop()});

    const lastActivity = conversation.get(`activities`).last();
    if (activityList.isScrolledToBottom()) {
      props.showScrollToBottomButton(false);
      props.updateHasNewMessage(false);
      if (conversation.get(`lastAcknowledgedActivityId`) !== lastActivity.id) {
        props.acknowledgeActivityOnServer(conversation, lastActivity, sparkInstance);
      }
    }
    else if (!widgetMessage.get(`showScrollToBottomButton`)) {
      props.showScrollToBottomButton(true);
    }

    if (activityList.isScrolledToTop() && conversation.get(`activities`).first().verb !== `create`) {
      props.loadPreviousMessages(
        conversation.get(`id`),
        conversation.get(`activities`).first().published,
        sparkInstance
      );
    }
  }

  /**
   * Gets the non-current user of a conversation
   *
   * @param {object} conversation
   * @returns {object}
   */
  @autobind
  getToUserFromConversation(conversation) {
    const props = this.props;
    if (!conversation.get(`participants`) || !props.user.get(`currentUser`)) {
      return null;
    }
    return conversation.get(`participants`).find((user) =>
      user.get(`id`) !== props.user.get(`currentUser`).id
    );
  }

  /**
   * Renders the conversation area of the widget
   *
   * @returns {object}
   */
  render() {
    const props = this.props;
    const {
      conversation,
      sparkInstance,
      user,
      widgetMessage
    } = props;
    const {formatMessage} = this.props.intl;

    const scrollToBottomLabel = widgetMessage.get(`hasNewMessage`) ? formatMessage(messages.newMessagesMessage) : ``;

    if (conversation && conversation.get(`id`)) {
      const isLoadingHistoryUp = conversation.getIn([`status`, `isLoadingHistoryUp`]);
      const toUser = this.getToUserFromConversation(conversation);
      const displayName = conversation.get(`displayName`) || toUser && toUser.get(`displayName`);

      return (
        <Dropzone
          activeClassName={styles.activeDropzone}
          className={styles.dropzone} // eslint-disable-line react/forbid-component-props
          disableClick
          disablePreview
          onDrop={this.handleFileDrop}
        >
          <div className={classNames(`ciscospark-activity-list-wrapper`, styles.activityListWrapper)}>
            <ScrollingActivity
              isLoadingHistoryUp={isLoadingHistoryUp}
              onScroll={this.handleScroll}
              ref={this.getActivityList}
            >
              {
                user.get(`currentUser`) &&
                <ActivityList
                  onActivityDelete={this.handleActivityDelete}
                  onActivityFlag={this.handleActivityFlag}
                  onActivityRetry={this.handleActivityRetry}
                />
              }
              <div className={classNames(`ciscospark-indicators`, styles.indicators)}><ReadReceipts /></div>
            </ScrollingActivity>
            {
              widgetMessage.get(`showScrollToBottomButton`) &&
              <ScrollToBottomButton
                label={scrollToBottomLabel}
                onClick={this.handleScrollToBottom}
              />
            }
          </div>
          <div className={classNames(`ciscospark-message-composer-wrapper`, styles.messageComposerWrapper)}>
            <MessageComposer
              conversation={conversation}
              onSubmit={this.handleMessageSubmit}
              placeholder={formatMessage(messages.messageComposerPlaceholder, {displayName})}
              sparkInstance={sparkInstance}
            />
          </div>
          {
            widgetMessage.get(`showAlertModal`) &&
            <ConfirmationModal
              actionButtonLabel={formatMessage(messages.deleteButtonLabel)}
              body={formatMessage(messages.deleteAlertBody)}
              cancelButtonLabel={formatMessage(messages.cancelButtonLabel)}
              onClickActionButton={this.handleConfirmActivityDelete}
              onClickCancelButton={this.handleCancelActivityDelete}
              title={formatMessage(messages.deleteAlertTitle)}
            />
          }
          <Cover message={formatMessage(messages.dropzoneCoverMessage)} />
        </Dropzone>
      );
    }
    return <LoadingScreen />;
  }
}

const injectedPropTypes = {
  avatar: PropTypes.object.isRequired,
  activity: PropTypes.object.isRequired,
  conversation: PropTypes.object.isRequired,
  flags: PropTypes.object.isRequired,
  sparkInstance: PropTypes.object,
  user: PropTypes.object.isRequired,
  widgetMessage: PropTypes.object.isRequired,
  acknowledgeActivityOnServer: PropTypes.func.isRequired,
  addFiles: PropTypes.func.isRequired,
  confirmDeleteActivity: PropTypes.func.isRequired,
  createConversation: PropTypes.func.isRequired,
  createNotification: PropTypes.func.isRequired,
  deleteActivityAndDismiss: PropTypes.func.isRequired,
  fetchAvatarsForUsers: PropTypes.func.isRequired,
  fetchFlags: PropTypes.func.isRequired,
  flagActivity: PropTypes.func.isRequired,
  getConversation: PropTypes.func.isRequired,
  hideDeleteModal: PropTypes.func.isRequired,
  loadMissingActivities: PropTypes.func.isRequired,
  loadPreviousMessages: PropTypes.func.isRequired,
  removeFlagFromServer: PropTypes.func.isRequired,
  receiveMercuryActivity: PropTypes.func.isRequired,
  receiveMercuryComment: PropTypes.func.isRequired,
  retryFailedActivity: PropTypes.func.isRequired,
  removeInflightActivity: PropTypes.func.isRequired,
  setScrollPosition: PropTypes.func.isRequired,
  setTyping: PropTypes.func.isRequired,
  showScrollToBottomButton: PropTypes.func.isRequired,
  updateHasNewMessage: PropTypes.func.isRequired,
  updateMercuryState: PropTypes.func.isRequired,
  space: PropTypes.object.isRequired
};

export const ownPropTypes = {
  muteNotifications: PropTypes.bool,
  onEvent: PropTypes.func,
  spaceId: PropTypes.string,
  toPersonEmail: PropTypes.string,
  toPersonId: PropTypes.string,
  eventNames: PropTypes.object
};

MessageWidget.propTypes = {
  ...ownPropTypes,
  ...injectedPropTypes
};

export default connect(
  getMessageWidgetProps,
  (dispatch) => bindActionCreators({
    acknowledgeActivityOnServer,
    addFiles,
    confirmDeleteActivity,
    createConversation,
    createNotification,
    deleteActivityAndDismiss,
    fetchAvatarsForUsers,
    fetchFlags,
    flagActivity,
    getConversation,
    hideDeleteModal,
    loadMissingActivities,
    loadPreviousMessages,
    removeFlagFromServer,
    receiveMercuryActivity,
    receiveMercuryComment,
    removeInflightActivity,
    retryFailedActivity,
    setScrollPosition,
    setTyping,
    showScrollToBottomButton,
    updateHasNewMessage,
    updateMercuryState
  }, dispatch)
)(MessageWidget);
