export const SET_CONNECTING = `mercury/SET_CONNECTING`;
export const SET_CONNECTED = `mercury/SET_CONNECTED`;

function updateStatusConnecting(value) {
  return {
    type: SET_CONNECTING,
    payload: value
  };
}

function updateStatusConnected(value) {
  return {
    type: SET_CONNECTED,
    payload: value
  };
}


export function connectToMercury(sparkInstance) {
  return (dispatch) => {
    if (sparkInstance) {
      const {
        canAuthorize,
        internal
      } = sparkInstance;
      const {
        device,
        mercury
      } = internal;

      if (canAuthorize && device.registered
        && !mercury.connected && !mercury.connecting) {
        dispatch(updateStatusConnecting(true));
        return mercury.connect().then(() =>
          sparkInstance.listenToAndRun(mercury, `change:connected`, () =>
            dispatch(updateStatusConnected(mercury.connected))
          )
        );
      }
      // Handle if mercury is already connected from previous instance
      else if (mercury.connected) {
        return dispatch(updateStatusConnected(mercury.connected));
      }
    }
    return Promise.resolve();
  };
}

