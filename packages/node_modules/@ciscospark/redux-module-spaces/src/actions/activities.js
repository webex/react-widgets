import {storeUsers} from '@ciscospark/redux-module-users';
import {storeActivities} from '@ciscospark/redux-module-activities';

import {TAG_LOCKED} from '../helpers';

import {updateSpaceStatus} from './spaces';

export const UPDATE_SPACE_WITH_ACTIVITY = 'spaces/UPDATE_SPACE_WITH_ACTIVITY';
export const DELETE_ACTIVITY_FROM_SPACE = 'spaces/DELETE_ACTIVITY_FROM_SPACE';
export const ACKNOWLEDGE_ACTIVITY = 'spaces/ACKNOWLEDGE_ACTIVITY';
export const ADD_ACTIVITIES_TO_SPACE = 'spaces/ADD_ACTIVITIES_TO_SPACE';


function acknowledgeActivity(activity) {
  return {
    type: ACKNOWLEDGE_ACTIVITY,
    payload: {
      activity
    }
  };
}


function deleteActivityFromSpace(spaceId, activityId) {
  return {
    type: DELETE_ACTIVITY_FROM_SPACE,
    description: 'This action does nothing. We wait for the delete event to come back from mercury.',
    payload: {
      spaceId,
      activityId
    }
  };
}

function addActivitiesToSpace(spaceId, activities) {
  const activitiesObject = [];
  activities.forEach(({id, published}) => {
    activitiesObject[id] = {id, published};
  });
  return {
    type: ADD_ACTIVITIES_TO_SPACE,
    payload: {
      spaceId,
      activities: activitiesObject
    }
  };
}

function processActivities(spaceId, activities) {
  return (dispatch) => {
    const activityActors = activities.map((a) => a.actor);
    dispatch(storeUsers(activityActors));
    dispatch(storeActivities(activities));
    dispatch(addActivitiesToSpace(activities));
    return Promise.resolve(activities);
  };
}


/**
 * Updates the target space with incoming Mercury activity
 *
 * @export
 * @param {Object} activity
 * @param {boolean} isSelf if actor is the same as this user
 * @param {boolean} isReadable if the activity is a readable activity
 * @returns {Object} redux action
 */
export function updateSpaceWithActivity(activity, isSelf, isReadable = false) {
  // We update lastReadableActivityDate, and the activity attached to this Space
  const space = {
    id: activity.target.id,
    latestActivity: activity.id,
    isLocked: activity.object.tags && activity.object.tags.includes(TAG_LOCKED)
  };

  if (isSelf) {
    space.lastSeenActivityDate = activity.published;
  }

  if (isReadable) {
    space.lastReadableActivityDate = activity.published;
  }

  return {
    type: UPDATE_SPACE_WITH_ACTIVITY,
    payload: {
      space
    }
  };
}

/**
 * Acknowledges (marks as read) an activity
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} conversation conversation instance
 * @param {Object} activity
 * @returns {function} Thunk
 */
export function acknowledgeActivityOnServer(sparkInstance, {conversation, activity}) {
  return (dispatch) =>
    sparkInstance.internal.conversation.acknowledge(conversation, activity)
      .then(() => {
        dispatch(acknowledgeActivity(activity));
        return Promise.resolve();
      });
}


/**
 * Deletes an activity from a conversation
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} conversation
 * @param {Object} activity
 * @returns {function} Thunk
 */
export function deleteActivity(sparkInstance, {conversation, spaceId, activity}) {
  return (dispatch) =>
    sparkInstance.internal.conversation.delete(conversation, activity)
      .then(() => {
        dispatch(deleteActivityFromSpace(spaceId, activity.id));
        return Promise.resolve();
      });
}

/**
 * Fetches activities that were posted after sinceDate
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options
 * @param {string} options.spaceId
 * @param {string} options.sinceDate
 * @returns {function} Thunk
 */
export function loadActivitiesSince(sparkInstance, {spaceId, sinceDate}) {
  function fetchAndMergeActivities(fetchConversationId, fetchSinceDate) {
    return (dispatch) => {
      const limit = 50;
      return sparkInstance.internal.conversation.listActivities({
        lastActivityFirst: false,
        fetchConversationId,
        limit,
        fetchSinceDate
      })
        .then((activities) => {
          if (activities.length) {
            dispatch(processActivities(spaceId, activities));
            if (activities.length === limit) {
            // We still have (possibly) more activities missing
              const lastActivityDate = activities[limit - 1].published;
              return fetchAndMergeActivities(fetchConversationId, lastActivityDate, dispatch);
            }
          }
          return Promise.resolve();
        });
    };
  }

  return (dispatch) => {
    dispatch(updateSpaceStatus(spaceId, {isLoadingActivitiesSince: true}));
    return dispatch(fetchAndMergeActivities(spaceId, sinceDate))
      .then(() => dispatch(updateSpaceStatus(spaceId, {isLoadingActivitiesSince: false})));
  };
}


/**
 * Loads activities for a conversation previous to the maxDate
 *
 * @export
 * @param {Object} sparkInstance
 * @param {Object} options
 * @param {string} options.spaceId
 * @param {string} options.maxDate
 * @returns {function} Thunk
 */
export function loadPreviousActivities(sparkInstance, {spaceId, maxDate}) {
  return (dispatch) => {
    dispatch(updateSpaceStatus(spaceId, {isLoadingHistory: true}));
    return sparkInstance.internal.conversation.listActivities({
      conversationId: spaceId,
      lastActivityFirst: true,
      limit: 20,
      maxDate
    })
      .then((activities) => {
        dispatch(processActivities(spaceId, activities));
        dispatch(updateSpaceStatus(spaceId, {isLoadingHistory: false}));
        return Promise.resolve(activities);
      });
  };
}
