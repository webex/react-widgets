const TAG_ONE_ON_ONE = 'ONE_ON_ONE';
const TAG_HIDDEN = 'HIDDEN';
export const TAG_LOCKED = 'LOCKED';

export function constructLastestActivity(items) {
  const latest = items.find((item) => ['tombstone', 'delete'].indexOf(item.verb) === -1);
  return latest;
}

function constructModerators(participants) {
  return participants.reduce((acc, p) => {
    if (p.roomProperties && p.roomProperties.isModerator) {
      acc.push(p.id);
    }
    return acc;
  }, []);
}

/**
 * Creates space object to be stored
 *
 * @param {Object} space
 * @param {Object} options
 * @returns {Object} formatted space object
 */
export function constructSpace(space, options = {}) {
  const activities = {};
  space.activities.items.forEach(({id, published}) => {
    activities[id] = {id, published};
  });
  const s = {
    avatar: space.avatar,
    displayName: space.displayName,
    id: space.id,
    url: space.url,
    locusUrl: space.locusUrl,
    lastReadableActivityDate: space.lastReadableActivityDate,
    lastSeenActivityDate: space.lastSeenActivityDate,
    conversationWebUrl: space.conversationWebUrl,
    participants: space.participants.items.map((p) => p.id),
    type: space.tags.includes(TAG_ONE_ON_ONE) ? 'direct' : 'group',
    published: space.published,
    tags: space.tags,
    isDecrypting: options.isDecrypting,
    isHidden: space.tags.includes(TAG_HIDDEN),
    isOneOnOne: space.tags.includes(TAG_ONE_ON_ONE),
    isLocked: space.tags.includes(TAG_LOCKED),
    activities,
    conversation: space
  };

  // Left spaces will still show up sometimes with empty activities
  if (!space.lastReadableActivityDate && space.published) {
    s.lastReadableActivityDate = space.published;
  }

  const moderators = constructModerators(space.participants.items);
  if (moderators) {
    s.moderators = moderators;
  }

  const latestActivity = constructLastestActivity(space.activities.items);
  if (latestActivity) {
    s.latestActivity = latestActivity.id;
  }

  if (space.team) {
    s.team = space.team.id;
  }

  return s;
}


/**
 * Creates space objects to be stored
 *
 * @param {Array} spaces
 * @returns {Array} formatted space object
 */
export function constructSpaces(spaces) {
  return spaces.map((space) => constructSpace(space));
}
