import React, {PropTypes, Component} from 'react';
import {bindActionCreators} from 'redux';
import {connect} from 'react-redux';
import classNames from 'classnames';
import autobind from 'autobind-decorator';
import {intlShape, injectIntl} from 'react-intl';

import {
  acceptIncomingCall,
  callUser,
  declineIncomingCall,
  listenForIncomingCalls,
  hangupCall,
  checkWebRTCSupport
} from '@ciscospark/redux-module-media';
import LoadingScreen from '@ciscospark/react-component-loading-screen';
import SparkLogo from '@ciscospark/react-component-spark-logo';
import {
  NOTIFICATION_TYPE_OTHER,
  createNotification
} from '@ciscospark/react-container-notifications';
import Ringtone, {
  RINGTONE_TYPE_RINGBACK,
  RINGTONE_TYPE_INCOMING
} from '@ciscospark/react-component-ringtone';

import InactiveCall from './components/call-inactive';
import ActiveCall from './components/call-active';
import IncomingCall from './components/call-incoming';
import messages from './messages';
import {
  updateLocalVideoPosition,
  updateLocalVideoState
} from './actions';
import styles from './styles.css';


export class MeetWidget extends Component {
  componentDidMount() {
    const props = this.props;
    const {
      media,
      spark
    } = props;

    if (media.getIn([`webRTC`, `isSupported`]) === null && !media.getIn([`webRTC`, `isCheckingSupport`])) {
      props.checkWebRTCSupport(spark);
    }
  }

  componentWillReceiveProps(nextProps) {
    const {
      media,
      conversation,
      spark,
      onEvent,
      shouldStartMeeting
    } = nextProps;

    if (media.getIn([`webRTC`, `isSupported`])) {
      if (shouldStartMeeting
        && !media.getIn([`status`, `isDialing`])
        && !media.getIn([`status`, `isConnected`])) {
        this.handleCall();
      }
      if (!media.getIn([`status`, `isListening`]) && conversation.locusUrl) {
        nextProps.listenForIncomingCalls(spark, conversation.locusUrl, onEvent);
      }
      if (media.getIn([`incomingCall`, `call`]) && !this.props.media.getIn([`incomingCall`, `call`])) {
        this.incomingCallNotification(media.getIn([`incomingCall`, `call`]));
      }
    }
  }


  shouldComponentUpdate(nextProps) {
    const props = this.props;
    return nextProps.media !== props.media
      || nextProps.toPersonAvatar !== props.toPersonAvatar
      || nextProps.widgetMeet !== props.widgetMeet;
  }

  /**
   * Event handler in case one isn't provided
   * @param {string} name
   * @param {object} data
   * @returns {undfined}
   */
  @autobind
  handleEvent(name, data) {
    const {onEvent} = this.props;
    if (typeof onEvent === `function`) {
      this.props.onEvent(name, data);
    }
  }

  @autobind
  handleCall() {
    const props = this.props;
    const {
      toPersonEmail,
      toPersonId,
      spark
    } = this.props;
    props.callUser({userIdOrEmail: toPersonId || toPersonEmail}, spark);
  }

  @autobind
  handleHangup() {
    const props = this.props;
    const {
      media
    } = props;
    props.hangupCall(media.get(`call`));
  }

  @autobind
  handleStartSendingAudio() {
    this.props.media.get(`call`).startSendingAudio();
  }

  @autobind
  handleStartSendingVideo() {
    this.props.media.get(`call`).startSendingVideo();
  }

  @autobind
  handleStopSendingAudio() {
    this.props.media.get(`call`).stopSendingAudio();
  }

  @autobind
  handleStopSendingVideo() {
    this.props.media.get(`call`).stopSendingVideo();
  }

  @autobind
  handleAnswer() {
    const {media} = this.props;
    const incomingCall = media.getIn([`incomingCall`, `call`]);
    this.props.acceptIncomingCall(incomingCall);
  }

  @autobind
  handleDecline() {
    const {media} = this.props;
    const incomingCall = media.getIn([`incomingCall`, `call`]);
    this.props.declineIncomingCall(incomingCall);
  }

  @autobind
  handleLocalVideoDragStop(e, data) {
    const {node, x, y} = data;
    const closest = this.findClosestPosition(node, {x, y});
    this.props.updateLocalVideoPosition(closest);
  }

  findClosestPosition(node, position) {
    const parent = node.offsetParent;
    const {x, y} = position;
    const nodeHeight = node.offsetHeight;
    const nodeWidth = node.offsetWidth;
    const parentHeight = parent.offsetHeight;
    const parentWidth = parent.offsetWidth;

    const x2 = (parentWidth - nodeWidth) / 2;
    const x3 = parentWidth - nodeWidth;
    const y2 = (parentHeight - nodeHeight) / 2;

    const snapTransform = [
      {x: -x3, y: 0}, {x: -x2, y: 0}, {x: 0, y: 0},
      {x: -x3, y: y2}, {x: 0, y: y2}
    ];

    const distances = snapTransform.map((val) => {
      const dx = x - val.x;
      const dy = y - val.y;
      return Math.sqrt(dx * dx + dy * dy);
    });

    return snapTransform[distances.indexOf(Math.min(...distances))];
  }

  incomingCallNotification(incomingCall) {
    const {intl} = this.props;
    const {formatMessage} = intl;
    const details = {
      username: incomingCall.from.person.name,
      message: formatMessage(messages.incomingCallMessage),
      avatar: this.props.avatar.get(`items`).toJS()[incomingCall.from.person.id]
    };
    this.props.createNotification(incomingCall.locusUrl, NOTIFICATION_TYPE_OTHER, details);
  }

  render() {
    const {
      intl,
      media,
      toPersonAvatar,
      toPersonName,
      widgetMeet
    } = this.props;

    const {formatMessage} = intl;

    const isWebRTCSupported = media.getIn([`webRTC`, `isSupported`]);
    if (isWebRTCSupported) {
      const {
        handleAnswer,
        handleCall,
        handleDecline,
        handleHangup,
        handleLocalVideoDragStop,
        handleStartSendingAudio,
        handleStartSendingVideo,
        handleStopSendingAudio,
        handleStopSendingVideo
      } = this;

      const callState = media.get(`callState`).toJS();
      const remoteUrl = media.getIn([`remoteStream`, `url`]);
      const localUrl = media.getIn([`localStream`, `url`]);
      const isConnected = media.getIn([`status`, `isConnected`]);
      const isDialing = media.getIn([`status`, `isDialing`]);
      const isActiveCall = isDialing || isConnected;
      const isIncomingCall = media.getIn([`status`, `isRinging`]);

      const ringtoneType = isDialing && RINGTONE_TYPE_RINGBACK || isIncomingCall && RINGTONE_TYPE_INCOMING;
      const isPlayingRingtone = isDialing || isIncomingCall;

      return (
        <div className={classNames(styles.meetWidgetContainer, `meet-widget-container`)}>
          {
            !isActiveCall && !isIncomingCall &&
            <InactiveCall
              intl={intl}
              onCallClick={handleCall}
              toPersonAvatar={toPersonAvatar}
              toPersonName={toPersonName}
            />
          }
          {
            isActiveCall &&
            <ActiveCall
              callState={callState}
              intl={intl}
              isConnected={isConnected}
              localMediaStreamUrl={localUrl}
              localVideoPosition={widgetMeet.get(`localVideoPosition`)}
              onHangupClick={handleHangup}
              onLocalVideoDragStop={handleLocalVideoDragStop}
              onStartSendingAudio={handleStartSendingAudio}
              onStartSendingVideo={handleStartSendingVideo}
              onStopSendingAudio={handleStopSendingAudio}
              onStopSendingVideo={handleStopSendingVideo}
              remoteMediaStreamUrl={remoteUrl}
              toPersonAvatar={toPersonAvatar}
              toPersonName={toPersonName}
            />
          }
          {
            isIncomingCall &&
            <IncomingCall
              avatarImage={toPersonAvatar}
              intl={intl}
              onAnswerClick={handleAnswer}
              onDeclineClick={handleDecline}
              toPersonName={toPersonName}
            />
          }
          {
            ringtoneType &&
            <Ringtone play={isPlayingRingtone} type={ringtoneType} />
          }
        </div>
      );
    }
    if (isWebRTCSupported === false) {
      return (
        <div className={classNames(styles.meetWidgetContainer, styles.noWebRtc, `meet-widget-container`)}>
          <div className={styles.noWebRtcLogo}><SparkLogo /></div>
          <div className={styles.noWebRtcMessage}>
            <p>{formatMessage(messages.noWebRTCBrowserSupportMessage)}</p>
            <p>{formatMessage(messages.useSupportedBrowserMessage)}</p>
          </div>
        </div>
      );
    }
    return <LoadingScreen />;
  }
}

const injectedPropTypes = {
  intl: intlShape.isRequired,
  avatar: PropTypes.object.isRequired,
  spark: PropTypes.object.isRequired,
  media: PropTypes.object.isRequired,
  conversation: PropTypes.object.isRequired,
  acceptIncomingCall: PropTypes.func.isRequired,
  callUser: PropTypes.func.isRequired,
  createNotification: PropTypes.func.isRequired,
  declineIncomingCall: PropTypes.func.isRequired,
  hangupCall: PropTypes.func.isRequired,
  listenForIncomingCalls: PropTypes.func.isRequired,
  widgetMeet: PropTypes.object.isRequired
};

MeetWidget.propTypes = {
  onEvent: PropTypes.func,
  shouldStartMeeting: PropTypes.bool,
  spark: PropTypes.object.isRequired,
  toPersonAvatar: PropTypes.string,
  toPersonId: PropTypes.string,
  toPersonName: PropTypes.string,
  ...injectedPropTypes
};

function mapStateToProps(state, ownProps) {
  return {
    spark: ownProps.spark || state.spark,
    avatar: state.avatar,
    media: state.media,
    conversation: state.conversation,
    widgetMeet: state.widgetMeet
  };
}

export default connect(
  mapStateToProps,
  (dispatch) => bindActionCreators({
    acceptIncomingCall,
    callUser,
    createNotification,
    declineIncomingCall,
    hangupCall,
    listenForIncomingCalls,
    updateLocalVideoPosition,
    updateLocalVideoState,
    checkWebRTCSupport
  }, dispatch)
)(injectIntl(MeetWidget));
