import {createSelector} from 'reselect';

import {validateAndDecodeId} from '@ciscospark/react-component-utils';

import {destinationTypes} from './';

const getWidget = (state) => state.widgetMeet;
const getCalls = (state) => state.media.byId;
const getAvatars = (state) => state.avatar;
const getUsers = (state) => state.users;
const getSpaces = (state) => state.spaces;
const getErrors = (state) => state.errors;
const getOwnProps = (state, ownProps) => ownProps;

const getCall = createSelector(
  [getOwnProps, getWidget, getCalls],
  (ownProps, widget, calls) => {
    let call;

    if (calls.has(widget.callId)) {
      call = calls.get(widget.callId);
    }
    else if (ownProps.call && ownProps.call.instance) {
      ({call} = ownProps);
    }

    // Patching in activeParticipantsCount with devices to support sip should be migrated to sdk
    if (call && call.instance && call.instance.locus && call.instance.locus.participants) {
      const count = call.instance.locus.participants.reduce((acc, p) =>
        acc + (p.state === 'JOINED' && p.type !== 'MEETING_BRIDGE' ? 1 : 0), 0);

      call = call.set('activeParticipantsCount', count);
    }

    return call;
  }
);

const getAvatarImage = createSelector(
  [getOwnProps, getAvatars, getWidget, getUsers],
  (ownProps, avatars, widget, users) => {
    const {
      toValue,
      toType
    } = widget;

    let avatarId;

    if (toType === destinationTypes.EMAIL) {
      avatarId = users.getIn(['byEmail', toValue]);
    }
    else if ([destinationTypes.EMAIL, destinationTypes.USERID, destinationTypes.SPACEID].includes(toType)) {
      avatarId = toValue;
    }

    return avatars.getIn(['items', avatarId]);
  }
);

const getDisplayName = createSelector(
  [getOwnProps, getWidget, getUsers, getSpaces],
  (ownProps, widget, users, spaces) => {
    const {
      toValue,
      toType
    } = widget;

    switch (toType) {
      case destinationTypes.SIP:
      case destinationTypes.PSTN:
        return toValue;
      case destinationTypes.EMAIL: {
        const userId = users.getIn(['byEmail', toValue]);

        return users.getIn(['byId', userId, 'displayName']);
      }
      case destinationTypes.USERID:
        return users.getIn(['byId', toValue, 'displayName']);
      case destinationTypes.SPACEID:
        if (ownProps.spaceDetails.type === 'direct') {
          return ownProps.spaceDetails.title;
        }

        return spaces.getIn(['byId', validateAndDecodeId(toValue).id, 'displayName']);
      default:
        return '';
    }
  }
);

const getMeetWidgetError = createSelector(
  [getErrors], (errors) => errors.get('errors').first()
);

const getMeetWidgetProps = createSelector(
  [
    getAvatarImage,
    getWidget,
    getCall,
    getDisplayName,
    getMeetWidgetError
  ],
  (avatarImage, widgetMeet, call, displayName, error) => {
    const props = {
      avatarImage,
      displayName,
      call,
      widgetMeet,
      error,
      localVideoPosition: widgetMeet.localVideoPosition,
      hasVideo: widgetMeet.toType !== destinationTypes.PSTN
    };

    let callProps;

    if (call) {
      // Is the call active?
      const {
        direction,
        isConnected,
        isDismissed,
        hasJoinedOnThisDevice,
        isRinging,
        localMediaStream,
        isCall,
        isAnswered,
        isSendingVideo
      } = call;

      callProps = {
        isRinging,
        isCall,
        callInstance: call.instance,
        isActive: isConnected && hasJoinedOnThisDevice || direction === 'out',
        isIncoming: direction === 'in' && !hasJoinedOnThisDevice && !isDismissed && !isAnswered
      };
      props.hasLocalVideo = localMediaStream && localMediaStream.active && isSendingVideo;
    }

    return {
      ...props,
      ...callProps
    };
  }
);

export default getMeetWidgetProps;
