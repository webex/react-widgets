const METRIC_NS = `ciscospark_widget_`; // eslint-disable-line no-unused-vars
const LOAD_START = `widget:ready`;

const metrics = {};
let metricsQueue = [];
const metricsCount = {}; // eslint-disable-line no-unused-vars
/**
 * Temporarily save metric to sessionStorage
 * @param {string} key
 * @param  {any} data
 * @returns {null}
 */
export function saveTempMetric(key, data) {
  metrics[key] = data;
}

export function getTempMetric(key) {
  const data = metrics[key];
  return {key, data};
}

// Helpers for saving metrics to queue before Spark is ready to send metrics

export function saveMetricToQueue(key, data) {
  metricsQueue.push({key, data});
}

export function saveElapsedTimeToQueue(key) {
  const elapsedTime = getElapsedTime();
  saveMetricToQueue(key, elapsedTime);
}

export function sendMetricsInQueue(spark) {
  metricsQueue.forEach(({key, data}) => {
    sendPerfMetric({key, data}, spark);
  });
  metricsQueue = [];
}

/**
 * Immediately send metric
 * @param  {object} metric
 * @param  {string} metric.key
 * @param  {any} metric.data
 * @param  {object} spark
 * @returns {Promise}
 */
export function sendPerfMetric({key, data, fields, tags}, spark) { // eslint-disable-line no-unused-vars
  // try {
  //   const [name, action] = key.split(`:`);
  //
  //   const count = metricsCount[key];
  //   if (count) {
  //     metricsCount[key] = count + 1;
  //   }
  //   else {
  //     metricsCount[key] = 1;
  //   }
  //
  //   const formattedData = {
  //     type: [`operational`],
  //     tags: Object.assign({
  //       action
  //     }, tags),
  //     fields: Object.assign({
  //       protocol: window.location.protocol,
  //       hostname: window.location.hostname,
  //       pathname: window.location.pathname,
  //       widgetVersion: process.env.REACT_CISCOSPARK_VERSION,
  //       jsSdkVersion: spark.version,
  //       iteration: metricsCount[key],
  //       data
  //     }, fields)
  //   };
  //   return spark.metrics.submitClientMetrics(`${METRIC_NS}${name}`, formattedData);
  // }
  // catch (e) {
  //   return console.warn(`clientMetrics: ${key} metrics was not sent`, e); // eslint-disable-line no-console
  // }
  return false;
}

/**
 * Send metric stored in session
 * @param  {string} key
 * @param  {object} spark
 * @returns {Promise}
 */
export function sendTempMetric(key, spark) {
  let metric = getTempMetric(key);
  metric = isNaN(metric) ? metric : Number(metric);
  return sendPerfMetric(metric, spark);
}

/**
 * Save start time
 * @param  {object} spark
 * @returns {null}
 */
export function saveAndSendLoadStart(spark) {
  const now = saveLoadStart();
  sendLoadStart(spark);
  return now;
}

/**
 * Send start time
 * @param  {object} spark
 * @returns {Promise}
 */
export function sendLoadStart(spark) {
  const data = getTempMetric(LOAD_START);
  return sendPerfMetric(data, spark);
}

/**
 * Save start time
 * @returns {number} now
 */
export function saveLoadStart() {
  const now = window.performance.now();
  saveTempMetric(LOAD_START, now);
  return now;
}

function getElapsedTime() {
  const now = window.performance.now();
  const start = getTempMetric(LOAD_START).data;
  return start && now - start;
}

/**
 * Save time elapsed for event
 * @type {type}
 */

export function saveElapsedTime(key) {
  const elapsedTime = getElapsedTime();
  saveTempMetric(key, elapsedTime);
}

/**
 * Send time from starting load
 * @param  {string} key
 * @param  {object} spark
 * @param  {object} fields
 * @returns {Promise}
 */
export function sendElapsedTimeMetric(key, spark, fields) {
  let elapsedTime = getElapsedTime();
  if (!elapsedTime) {
    saveAndSendLoadStart(spark);
    elapsedTime = 0;
  }
  return sendPerfMetric({key, data: elapsedTime, fields}, spark);
}

export function sendDurationMetric(key, start, end, spark) {
  const startMetric = getTempMetric(start).data;
  const endMetric = getTempMetric(end).data;
  return sendPerfMetric({key, data: endMetric - startMetric}, spark);
}
